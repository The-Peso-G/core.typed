<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.core.typed - Gradual Typing 0.3.21 API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">core.typed API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">Gradual Typing</span> <span id="version">0.3.21</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="http://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ASeq" class="toc-entry-anchor">ASeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/AVec" class="toc-entry-anchor">AVec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Agent1" class="toc-entry-anchor">Agent1</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Agent2" class="toc-entry-anchor">Agent2</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/All" class="toc-entry-anchor">All</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Any" class="toc-entry-anchor">Any</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/AnyInteger" class="toc-entry-anchor">AnyInteger</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/AnyValue" class="toc-entry-anchor">AnyValue</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Assoc" class="toc-entry-anchor">Assoc</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Atom1" class="toc-entry-anchor">Atom1</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Atom2" class="toc-entry-anchor">Atom2</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/BlockingDeref" class="toc-entry-anchor">BlockingDeref</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Bool" class="toc-entry-anchor">Bool</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Coll" class="toc-entry-anchor">Coll</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/CountRange" class="toc-entry-anchor">CountRange</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Delay" class="toc-entry-anchor">Delay</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Deref" class="toc-entry-anchor">Deref</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Difference" class="toc-entry-anchor">Difference</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Dissoc" class="toc-entry-anchor">Dissoc</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/EmptyCount" class="toc-entry-anchor">EmptyCount</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/EmptySeqable" class="toc-entry-anchor">EmptySeqable</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ExInfo" class="toc-entry-anchor">ExInfo</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ExactCount" class="toc-entry-anchor">ExactCount</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Fn" class="toc-entry-anchor">Fn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Future" class="toc-entry-anchor">Future</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Get" class="toc-entry-anchor">Get</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/HMap" class="toc-entry-anchor">HMap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/HSeq" class="toc-entry-anchor">HSeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/HSequential" class="toc-entry-anchor">HSequential</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/HSet" class="toc-entry-anchor">HSet</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/HVec" class="toc-entry-anchor">HVec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Hierarchy" class="toc-entry-anchor">Hierarchy</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/I" class="toc-entry-anchor">I</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/IFn" class="toc-entry-anchor">IFn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Id" class="toc-entry-anchor">Id</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Int" class="toc-entry-anchor">Int</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Keyword" class="toc-entry-anchor">Keyword</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Kw" class="toc-entry-anchor">Kw</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/List" class="toc-entry-anchor">List</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Map" class="toc-entry-anchor">Map</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Multi" class="toc-entry-anchor">Multi</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Namespace" class="toc-entry-anchor">Namespace</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Nilable" class="toc-entry-anchor">Nilable</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NilableNonEmptyASeq" class="toc-entry-anchor">NilableNonEmptyASeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NilableNonEmptySeq" class="toc-entry-anchor">NilableNonEmptySeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptyASeq" class="toc-entry-anchor">NonEmptyASeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptyAVec" class="toc-entry-anchor">NonEmptyAVec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptyColl" class="toc-entry-anchor">NonEmptyColl</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptyCount" class="toc-entry-anchor">NonEmptyCount</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptyLazySeq" class="toc-entry-anchor">NonEmptyLazySeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptySeq" class="toc-entry-anchor">NonEmptySeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptySeqable" class="toc-entry-anchor">NonEmptySeqable</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/NonEmptyVec" class="toc-entry-anchor">NonEmptyVec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Nothing" class="toc-entry-anchor">Nothing</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Num" class="toc-entry-anchor">Num</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Option" class="toc-entry-anchor">Option</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Pred" class="toc-entry-anchor">Pred</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Promise" class="toc-entry-anchor">Promise</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Proxy" class="toc-entry-anchor">Proxy</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Rec" class="toc-entry-anchor">Rec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Ref1" class="toc-entry-anchor">Ref1</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Ref2" class="toc-entry-anchor">Ref2</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Reversible" class="toc-entry-anchor">Reversible</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Seq" class="toc-entry-anchor">Seq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Seqable" class="toc-entry-anchor">Seqable</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Sequential" class="toc-entry-anchor">Sequential</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/SequentialSeq" class="toc-entry-anchor">SequentialSeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/SequentialSeqable" class="toc-entry-anchor">SequentialSeqable</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Set" class="toc-entry-anchor">Set</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/SortedSet" class="toc-entry-anchor">SortedSet</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Stack" class="toc-entry-anchor">Stack</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Str" class="toc-entry-anchor">Str</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Sym" class="toc-entry-anchor">Sym</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Symbol" class="toc-entry-anchor">Symbol</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/TFn" class="toc-entry-anchor">TFn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/U" class="toc-entry-anchor">U</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Val" class="toc-entry-anchor">Val</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Value" class="toc-entry-anchor">Value</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Var1" class="toc-entry-anchor">Var1</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Var2" class="toc-entry-anchor">Var2</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/Vec" class="toc-entry-anchor">Vec</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann" class="toc-entry-anchor">ann</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-datatype" class="toc-entry-anchor">ann-datatype</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-form" class="toc-entry-anchor">ann-form</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-interface" class="toc-entry-anchor">ann-interface</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-many" class="toc-entry-anchor">ann-many</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-precord" class="toc-entry-anchor">ann-precord</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-protocol" class="toc-entry-anchor">ann-protocol</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ann-record" class="toc-entry-anchor">ann-record</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/atom" class="toc-entry-anchor">atom</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/atom&gt;" class="toc-entry-anchor">atom&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/cast" class="toc-entry-anchor">cast</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/cf" class="toc-entry-anchor">cf</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/check-form*" class="toc-entry-anchor">check-form*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/check-form-info" class="toc-entry-anchor">check-form-info</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/check-ns" class="toc-entry-anchor">check-ns</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/check-ns-info" class="toc-entry-anchor">check-ns-info</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/declare-alias-kind" class="toc-entry-anchor">declare-alias-kind</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/declare-datatypes" class="toc-entry-anchor">declare-datatypes</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/declare-names" class="toc-entry-anchor">declare-names</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/declare-protocols" class="toc-entry-anchor">declare-protocols</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/def" class="toc-entry-anchor">def</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/def-alias" class="toc-entry-anchor">def-alias</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/def&gt;" class="toc-entry-anchor">def&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/defalias" class="toc-entry-anchor">defalias</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/defn" class="toc-entry-anchor">defn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/defn&gt;" class="toc-entry-anchor">defn&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/defprotocol" class="toc-entry-anchor">defprotocol</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/defprotocol&gt;" class="toc-entry-anchor">defprotocol&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/doseq" class="toc-entry-anchor">doseq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/doseq&gt;" class="toc-entry-anchor">doseq&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/dotimes" class="toc-entry-anchor">dotimes</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/dotimes&gt;" class="toc-entry-anchor">dotimes&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/envs" class="toc-entry-anchor">envs</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/fn" class="toc-entry-anchor">fn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/fn&gt;" class="toc-entry-anchor">fn&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/for" class="toc-entry-anchor">for</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/for&gt;" class="toc-entry-anchor">for&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/inst" class="toc-entry-anchor">inst</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/inst-ctor" class="toc-entry-anchor">inst-ctor</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/install" class="toc-entry-anchor">install</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/into-array&gt;" class="toc-entry-anchor">into-array&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/let" class="toc-entry-anchor">let</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/letfn&gt;" class="toc-entry-anchor">letfn&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/load-if-needed" class="toc-entry-anchor">load-if-needed</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/loop" class="toc-entry-anchor">loop</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/loop&gt;" class="toc-entry-anchor">loop&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/method-type" class="toc-entry-anchor">method-type</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/nilable-param" class="toc-entry-anchor">nilable-param</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/non-nil-return" class="toc-entry-anchor">non-nil-return</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/override-constructor" class="toc-entry-anchor">override-constructor</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/override-method" class="toc-entry-anchor">override-method</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/pfn&gt;" class="toc-entry-anchor">pfn&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/pred" class="toc-entry-anchor">pred</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/print-env" class="toc-entry-anchor">print-env</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/print-filterset" class="toc-entry-anchor">print-filterset</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ref" class="toc-entry-anchor">ref</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/ref&gt;" class="toc-entry-anchor">ref&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/reset-caches" class="toc-entry-anchor">reset-caches</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/statistics" class="toc-entry-anchor">statistics</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/tc-ignore" class="toc-entry-anchor">tc-ignore</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/typed-deps" class="toc-entry-anchor">typed-deps</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/untyped-var" class="toc-entry-anchor">untyped-var</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/var-coverage" class="toc-entry-anchor">var-coverage</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/var&gt;" class="toc-entry-anchor">var&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/warn-on-unannotated-vars" class="toc-entry-anchor">warn-on-unannotated-vars</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed/when-let-fail" class="toc-entry-anchor">when-let-fail</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.async">clojure.core.typed.async</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.base-env-common">clojure.core.typed.base-env-common</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check-form-cljs">clojure.core.typed.check-form-cljs</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check-form-cljs/check-form-cljs" class="toc-entry-anchor">check-form-cljs</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check-ns-clj">clojure.core.typed.check-ns-clj</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check-ns-clj/check-ns-info" class="toc-entry-anchor">check-ns-info</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check.def">clojure.core.typed.check.def</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.def/add-checks-normal-def" class="toc-entry-anchor">add-checks-normal-def</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.def/check-def" class="toc-entry-anchor">check-def</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.def/check-defmacro-or-declare" class="toc-entry-anchor">check-defmacro-or-declare</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.def/check-normal-def" class="toc-entry-anchor">check-normal-def</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.def/defmacro-or-declare?" class="toc-entry-anchor">defmacro-or-declare?</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check.fn-methods">clojure.core.typed.check.fn-methods</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.fn-methods/check-fni" class="toc-entry-anchor">check-fni</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.fn-methods/expected-for-method" class="toc-entry-anchor">expected-for-method</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check.monitor">clojure.core.typed.check.monitor</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.monitor/check-monitor" class="toc-entry-anchor">check-monitor</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check.special.ann-form">clojure.core.typed.check.special.ann-form</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.special.ann-form/add-checks-ann-form" class="toc-entry-anchor">add-checks-ann-form</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.special.ann-form/ann-form-annotation" class="toc-entry-anchor">ann-form-annotation</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.special.ann-form/check-ann-form" class="toc-entry-anchor">check-ann-form</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.special.ann-form/parse-annotation" class="toc-entry-anchor">parse-annotation</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.check.value">clojure.core.typed.check.value</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.value/check-value" class="toc-entry-anchor">check-value</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.check.value/unquote-val" class="toc-entry-anchor">unquote-val</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.collect-utils">clojure.core.typed.collect-utils</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.collect-utils/collect-ns*" class="toc-entry-anchor">collect-ns*</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.contract">clojure.core.typed.contract</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/Blame" class="toc-entry-anchor">Blame</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/CheckedISeq" class="toc-entry-anchor">CheckedISeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/Contract" class="toc-entry-anchor">Contract</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/-&gt;Blame" class="toc-entry-anchor">-&gt;Blame</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/-&gt;CheckedISeq" class="toc-entry-anchor">-&gt;CheckedISeq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/-&gt;Contract" class="toc-entry-anchor">-&gt;Contract</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/and-c" class="toc-entry-anchor">and-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/any-c" class="toc-entry-anchor">any-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/contract" class="toc-entry-anchor">contract</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/count-range-c" class="toc-entry-anchor">count-range-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/equiv-c" class="toc-entry-anchor">equiv-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/false-c" class="toc-entry-anchor">false-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/flat-val-c" class="toc-entry-anchor">flat-val-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/hmap-c" class="toc-entry-anchor">hmap-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/identical-c" class="toc-entry-anchor">identical-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/ifn-c" class="toc-entry-anchor">ifn-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/instance-c" class="toc-entry-anchor">instance-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/int-c" class="toc-entry-anchor">int-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/make-blame" class="toc-entry-anchor">make-blame</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/make-contract" class="toc-entry-anchor">make-contract</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/make-flat-contract" class="toc-entry-anchor">make-flat-contract</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/map-&gt;Blame" class="toc-entry-anchor">map-&gt;Blame</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/map-&gt;Contract" class="toc-entry-anchor">map-&gt;Contract</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/nil-c" class="toc-entry-anchor">nil-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/or-c" class="toc-entry-anchor">or-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/seqable-c" class="toc-entry-anchor">seqable-c</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/swap-blame" class="toc-entry-anchor">swap-blame</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/throw-blame" class="toc-entry-anchor">throw-blame</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.contract/true-c" class="toc-entry-anchor">true-c</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.current-impl">clojure.core.typed.current-impl</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.current-impl/create-env" class="toc-entry-anchor">create-env</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.hole">clojure.core.typed.hole</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.hole/NoisyHole" class="toc-entry-anchor">NoisyHole</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.hole/-&gt;NoisyHole" class="toc-entry-anchor">-&gt;NoisyHole</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.hole/noisy-hole" class="toc-entry-anchor">noisy-hole</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.hole/silent-hole" class="toc-entry-anchor">silent-hole</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.lang">clojure.core.typed.lang</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/default-eval" class="toc-entry-anchor">default-eval</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/default-load1" class="toc-entry-anchor">default-load1</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/extensible-eval" class="toc-entry-anchor">extensible-eval</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/extensible-load" class="toc-entry-anchor">extensible-load</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/file-lang" class="toc-entry-anchor">file-lang</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/install" class="toc-entry-anchor">install</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/lang-dispatch" class="toc-entry-anchor">lang-dispatch</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/monkey-patch-extensible-eval" class="toc-entry-anchor">monkey-patch-extensible-eval</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/monkey-patch-extensible-load" class="toc-entry-anchor">monkey-patch-extensible-load</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.lang/ns-lang" class="toc-entry-anchor">ns-lang</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.load">clojure.core.typed.load</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load/install" class="toc-entry-anchor">install</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load/install-typed-load" class="toc-entry-anchor">install-typed-load</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load/load-typed-file" class="toc-entry-anchor">load-typed-file</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load/monkey-patch-typed-eval" class="toc-entry-anchor">monkey-patch-typed-eval</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load/monkey-patch-typed-load" class="toc-entry-anchor">monkey-patch-typed-load</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load/typed-load1" class="toc-entry-anchor">typed-load1</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.load1">clojure.core.typed.load1</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load1/install" class="toc-entry-anchor">install</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load1/install-typed-load" class="toc-entry-anchor">install-typed-load</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load1/load-typed-file" class="toc-entry-anchor">load-typed-file</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load1/monkey-patch-typed-eval" class="toc-entry-anchor">monkey-patch-typed-eval</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load1/monkey-patch-typed-load" class="toc-entry-anchor">monkey-patch-typed-load</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.load1/typed-load1" class="toc-entry-anchor">typed-load1</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.macros">clojure.core.typed.macros</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/ann-form" class="toc-entry-anchor">ann-form</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/atom" class="toc-entry-anchor">atom</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/def" class="toc-entry-anchor">def</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/defn" class="toc-entry-anchor">defn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/defprotocol" class="toc-entry-anchor">defprotocol</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/fn" class="toc-entry-anchor">fn</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/let" class="toc-entry-anchor">let</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/loop" class="toc-entry-anchor">loop</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/parse-colon" class="toc-entry-anchor">parse-colon</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/ref" class="toc-entry-anchor">ref</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/tc-ignore" class="toc-entry-anchor">tc-ignore</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.macros/when-let-fail" class="toc-entry-anchor">when-let-fail</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.runtime-check">clojure.core.typed.runtime-check</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.runtime-check/check" class="toc-entry-anchor">check</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.statistics">clojure.core.typed.statistics</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.statistics/statistics" class="toc-entry-anchor">statistics</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.typed.util-vars">clojure.core.typed.util-vars</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.util-vars/*trace-checker*" class="toc-entry-anchor">*trace-checker*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.util-vars/*verbose-forms*" class="toc-entry-anchor">*verbose-forms*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.typed.util-vars/*verbose-types*" class="toc-entry-anchor">*verbose-types*</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.typed">clojure.core.typed</span>
  - <span id="header-project">Gradual Typing</span> <span id="header-version">0.3.21</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.core.typed</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/core.typed/">http://github.com/clojure/core.typed/</a></div>
<pre id="namespace-docstr">This namespace contains typed wrapper macros, type aliases
and functions for type checking Clojure code. check-ns is the interface
for checking namespaces, cf for checking individual forms.</pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ASeq">ASeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (ASeq t)
</pre>
    <pre id="var-docstr">A sequential seq returned from clojure.core/seq</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AVec">AVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (AVec t)
</pre>
    <pre id="var-docstr">A persistent vector returned from clojure.core/vector (and others)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Agent1">Agent1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Agent1 t)
</pre>
    <pre id="var-docstr">An agent that can read and write type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Agent2">Agent2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Agent2 t t)
</pre>
    <pre id="var-docstr">An agent that can write type w and read type r.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/All">All</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (All binder type)
</pre>
    <pre id="var-docstr">A polymorphic binder</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1499">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Any">Any</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Any
</pre>
    <pre id="var-docstr">Any is the top type that contains all types.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1359">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AnyInteger">AnyInteger</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: AnyInteger
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/integer?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AnyValue">AnyValue</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: AnyValue
</pre>
    <pre id="var-docstr">AnyValue contains all Value singleton types</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1364">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Assoc">Assoc</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Assoc type type-pairs*)
</pre>
    <pre id="var-docstr">A type representing an assoc operation</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1478">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Atom1">Atom1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Atom1 t)
</pre>
    <pre id="var-docstr">An atom that can read and write type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Atom2">Atom2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Atom2 t)
</pre>
    <pre id="var-docstr">An atom that can write type w and read type r.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/BlockingDeref">BlockingDeref</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (BlockingDeref t)
</pre>
    <pre id="var-docstr">A Clojure blocking derefable (see clojure.core/deref).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Bool">Bool</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Bool
</pre>
    <pre id="var-docstr">A boolean</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Coll">Coll</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Coll t)
</pre>
    <pre id="var-docstr">A persistent collection with member type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/CountRange">CountRange</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (CountRange Integer)
       (CountRange Integer Integer)
</pre>
    <pre id="var-docstr">A type representing a range of counts for a collection</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1397">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Delay">Delay</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Delay t)
</pre>
    <pre id="var-docstr">A Clojure delay (see clojure.core/{delay,force}).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Deref">Deref</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Deref t)
</pre>
    <pre id="var-docstr">A Clojure derefable (see clojure.core/deref).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Difference">Difference</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Difference type type type*)
</pre>
    <pre id="var-docstr">Difference represents a difference of types.

(Difference t s) is the same as type t with type s removed.

eg. (Difference (U Int Long) Int) =&gt; Long
    (Difference (U Num nil) nil)  =&gt; Num
</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1408">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Dissoc">Dissoc</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Dissoc type type*)
</pre>
    <pre id="var-docstr">A type representing a dissoc operation</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1483">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/EmptyCount">EmptyCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: EmptyCount
</pre>
    <pre id="var-docstr">The type of all things with count 0. Use as part of an intersection.
eg. See EmptySeqable.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/EmptySeqable">EmptySeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (EmptySeqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x
with count 0.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ExInfo">ExInfo</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: ExInfo
</pre>
    <pre id="var-docstr">A Clojure custom exception type.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ExactCount">ExactCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (ExactCount Integer)
</pre>
    <pre id="var-docstr">A type representing a precise count for a collection</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1403">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Fn">Fn</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Fn
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/fn?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Future">Future</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Future t)
</pre>
    <pre id="var-docstr">A Clojure future (see clojure.core/{future-call,future}).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Get">Get</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Get type type)
       (Get type type type)
</pre>
    <pre id="var-docstr">A type representing a get operation</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1488">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HMap">HMap</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HMap :mandatory {Constant Type*} :optional {Constant Type*} :absent-keys #{Constant*} :complete? Boolean)
       (quote {Constant Type*})
</pre>
    <pre id="var-docstr">HMap is a type for heterogeneous maps.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1431">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HSeq">HSeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HSeq [fixed*] :filter-sets [FS*] :objects [obj*])
       (HSeq [fixed* rest *] :filter-sets [FS*] :objects [obj*])
       (HSeq [fixed* drest ... bound] :filter-sets [FS*] :objects [obj*])
</pre>
    <pre id="var-docstr">HSeq is a type for heterogeneous seqs</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1447">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HSequential">HSequential</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HSequential [fixed*] :filter-sets [FS*] :objects [obj*])
       (HSequential [fixed* rest *] :filter-sets [FS*] :objects [obj*])
       (HSequential [fixed* drest ... bound] :filter-sets [FS*] :objects [obj*])
</pre>
    <pre id="var-docstr">HSequential is a type for heterogeneous sequential collections</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1440">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HSet">HSet</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HSet #{fixed*} :complete? Boolean)
</pre>
    <pre id="var-docstr">HSet is a type for heterogeneous sets.
Takes a set of simple values. By default
:complete? is true.

eg. (HSet #{:a :b :c} :complete? true)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1454">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HVec">HVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HVec [fixed*] :filter-sets [FS*] :objects [obj*])
       (HVec [fixed* type *] :filter-sets [FS*] :objects [obj*])
       (HVec [fixed* type ... bound] :filter-sets [FS*] :objects [obj*])
       (quote [fixed*])
       (quote [fixed* type *])
       (quote [fixed* type ... bound])
</pre>
    <pre id="var-docstr">HVec is a type for heterogeneous vectors.
It extends clojure.core.typed/Vec and is a subtype
of clojure.core.typed/HSequential.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1419">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Hierarchy">Hierarchy</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Hierarchy
</pre>
    <pre id="var-docstr">A hierarchy for use with derive, isa? etc.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/I">I</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (I type*)
</pre>
    <pre id="var-docstr">I represents an intersection of types</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1380">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/IFn">IFn</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (IFn ArityVec+)
       [fixed* -&gt; ret :filters {:then fl, :else fl} :object {:id Foo, :path Bar}]
       [fixed* rest * -&gt; ret :filters {:then fl, :else fl} :object {:id Foo, :path Bar}]
       [fixed* drest ... bound -&gt; ret :filters {:then fl, :else fl} :object {:id Foo, :path Bar}]
</pre>
    <pre id="var-docstr">An ordered intersection type of function arities.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1463">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Id">Id</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Id
</pre>
    <pre id="var-docstr">The identity function at the type level.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Int">Int</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Int
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/integer?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Keyword">Keyword</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Keyword
</pre>
    <pre id="var-docstr">A keyword</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Kw">Kw</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Kw
</pre>
    <pre id="var-docstr">A keyword</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/List">List</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (List t)
</pre>
    <pre id="var-docstr">A Clojure persistent list.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Map">Map</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Map t t)
</pre>
    <pre id="var-docstr">A persistent map with keys k and vals v.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Multi">Multi</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Multi
</pre>
    <pre id="var-docstr">A Clojure multimethod.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Namespace">Namespace</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Namespace
</pre>
    <pre id="var-docstr">A namespace</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Nilable">Nilable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Nilable t)
</pre>
    <pre id="var-docstr">A union of x and nil.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NilableNonEmptyASeq">NilableNonEmptyASeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NilableNonEmptyASeq t)
</pre>
    <pre id="var-docstr">The result of clojure.core/seq.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NilableNonEmptySeq">NilableNonEmptySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NilableNonEmptySeq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x with count greater than 0, or nil.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyASeq">NonEmptyASeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyASeq t)
</pre>
    <pre id="var-docstr">A sequential non-empty seq retured from clojure.core/seq</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyAVec">NonEmptyAVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyAVec t)
</pre>
    <pre id="var-docstr">A persistent vector returned from clojure.core/vector (and others) and count greater than 0.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyColl">NonEmptyColl</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyColl t)
</pre>
    <pre id="var-docstr">A persistent collection with member type x and count greater than 0.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyCount">NonEmptyCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: NonEmptyCount
</pre>
    <pre id="var-docstr">The type of all things with count greater than 0. Use as part of an intersection.
eg. See NonEmptySeq</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyLazySeq">NonEmptyLazySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyLazySeq t)
</pre>
    <pre id="var-docstr">A non-empty lazy sequence of type t</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptySeq">NonEmptySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptySeq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x with count greater than 0.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptySeqable">NonEmptySeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptySeqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x
with count greater than 0.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyVec">NonEmptyVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyVec t)
</pre>
    <pre id="var-docstr">A persistent vector with member type x and count greater than 0.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Nothing">Nothing</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Nothing
</pre>
    <pre id="var-docstr">Nothing is the bottom type that inhabits no types
except itself.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1374">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Num">Num</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Num
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/number?</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Option">Option</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Option t)
</pre>
    <pre id="var-docstr">A union of x and nil.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Pred">Pred</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Pred type)
</pre>
    <pre id="var-docstr">A predicate for the given type.

eg. Type for integer?: (Pred Int)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1471">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Promise">Promise</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Promise t)
</pre>
    <pre id="var-docstr">A Clojure promise (see clojure.core/{promise,deliver}).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Proxy">Proxy</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Proxy
</pre>
    <pre id="var-docstr">A Clojure proxy.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Rec">Rec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Rec binder type)
</pre>
    <pre id="var-docstr">A recursive type</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1494">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Ref1">Ref1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Ref1 t)
</pre>
    <pre id="var-docstr">A ref that can read and write type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Ref2">Ref2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Ref2 w r)
</pre>
    <pre id="var-docstr">A ref that can write type w and read type r.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Reversible">Reversible</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Reversible t)
</pre>
    <pre id="var-docstr">A Clojure reversible collection.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Seq">Seq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Seq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Seqable">Seqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Seqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Sequential">Sequential</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Sequential
</pre>
    <pre id="var-docstr">A sequential collection.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SequentialSeq">SequentialSeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SequentialSeq t)
</pre>
    <pre id="var-docstr">A Clojure sequential sequence. Seq's aren't always Sequential.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SequentialSeqable">SequentialSeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SequentialSeqable t)
</pre>
    <pre id="var-docstr">A sequential, seqable collection. Seq's aren't always Sequential.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Set">Set</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Set t)
</pre>
    <pre id="var-docstr">A persistent set with member type x</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SortedSet">SortedSet</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SortedSet t)
</pre>
    <pre id="var-docstr">A sorted persistent set with member type x</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Stack">Stack</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Stack t)
</pre>
    <pre id="var-docstr">A Clojure stack.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Str">Str</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Str
</pre>
    <pre id="var-docstr">A string</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Sym">Sym</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Sym
</pre>
    <pre id="var-docstr">A symbol</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Symbol">Symbol</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Symbol
</pre>
    <pre id="var-docstr">A symbol</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/TFn">TFn</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (TFn binder type)
</pre>
    <pre id="var-docstr">A type function</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1504">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/U">U</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (U type*)
</pre>
    <pre id="var-docstr">U represents a union of types</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1369">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Val">Val</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Val Constant)
       (quote Constant)
</pre>
    <pre id="var-docstr">A singleton type for a constant value.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1385">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Value">Value</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Value Constant)
       (quote Constant)
</pre>
    <pre id="var-docstr">A singleton type for a constant value.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1391">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Var1">Var1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Var1 t)
</pre>
    <pre id="var-docstr">An var that can read and write type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Var2">Var2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Var2 w r)
</pre>
    <pre id="var-docstr">An var that can write type w and read type r.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Vec">Vec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Vec t)
</pre>
    <pre id="var-docstr">A persistent vector with member type x.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1523">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann">ann</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann varsym typesyn)
</pre>
    <pre id="var-docstr">Annotate varsym with type. If unqualified, qualify in the current namespace.
If varsym has metadata {:no-check true}, ignore definitions of varsym 
while type checking.

If annotating vars in namespaces other than the current one, a fully
qualified symbol must be provided. Note that namespace aliases are not
recognised: the *full* namespace must be given in the first part of the symbol.

eg. ; annotate the var foo in this namespace
    (ann foo [Number -&gt; Number])

    ; annotate a var in another namespace
    (ann another.ns/bar [-&gt; nil])
 
    ; don't check this var
    (ann ^:no-check foobar [Integer -&gt; String])</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1745">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-datatype">ann-datatype</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-datatype dname [field :- type*] opts*)
       (ann-datatype binder dname [field :- type*] opts*)
</pre>
    <pre id="var-docstr">Annotate datatype Class name dname with expected fields.
If unqualified, qualify in the current namespace.
Takes an optional type variable binder before the name.

Fields must be specified in the same order as presented 
in deftype, with exactly the same field names.

Also annotates datatype factories and constructors.

Binder is a vector of specs. Each spec is a vector
with the variable name as the first entry, followed by
keyword arguments:
- :variance (mandatory)
  The declared variance of the type variable. Possible
  values are :covariant, :contravariant and :invariant.
- :&lt; (optional)
  The upper type bound of the type variable. Defaults to
  Any, or the most general type of the same rank as the
  lower bound.
- :&gt; (optional)
  The lower type bound of the type variable. Defaults to
  Nothing, or the least general type of the same rank as the
  upper bound.

eg. ; a datatype in the current namespace
    (ann-datatype MyDatatype [a :- Number,
                              b :- Long])

    ; a datatype in another namespace
    (ann-datatype another.ns.TheirDatatype
                  [str :- String,
                   vec :- (Vec Number)])

    ; a datatype, polymorphic in a
    (ann-datatype [[a :variance :covariant]]
                  MyPolyDatatype
                  [str :- String,
                   vec :- (Vec Number)
                   ply :- (Set a)])</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1796">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-form">ann-form</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-form form ty)
</pre>
    <pre id="var-docstr">Annotate a form with an expected type.</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-interface">ann-interface</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-interface vbnd varsym &amp; methods)
       (ann-interface varsym &amp; methods)
</pre>
    <pre id="var-docstr">Annotate a possibly polymorphic interface (created with definterface) with method types.

Note: Unlike ann-protocol, omit the target ('this') argument in the method signatures.

eg. (ann-interface IFoo
      bar
      (Fn [-&gt; Any]
          [Number Symbol -&gt; Any])
      baz
      [Number -&gt; Number])
    (definterface IFoo
      (bar [] [n s])
      (baz [n]))

    ; polymorphic protocol
    ; x is scoped in the methods
    (ann-protocol [[x :variance :covariant]]
      IFooPoly
      bar
      (Fn [-&gt; Any]
          [Number Symbol -&gt; Any])
      baz
      [Number -&gt; Number])
    (definterface IFooPoly
      (bar [] [n s])
      (baz [n]))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2029">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-many">ann-many</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-many t &amp; vs)
</pre>
    <pre id="var-docstr">Annotate several vars with type t.

eg. (ann-many FakeSearch
              web1 web2 image1 image2 video1 video2)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1782">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-precord">ann-precord</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-precord dname vbnd fields &amp; {ancests :unchecked-ancestors, rplc :replace, :as opt})
</pre>
    <pre id="var-docstr">Annotate record Class name dname with a polymorphic binder and expected fields.
If unqualified, qualify in the current namespace.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1955">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-protocol">ann-protocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-protocol vbnd varsym &amp; methods)
       (ann-protocol varsym &amp; methods)
</pre>
    <pre id="var-docstr">Annotate a possibly polymorphic protocol var with method types.

eg. (ann-protocol IFoo
      bar
      (Fn [IFoo -&gt; Any]
          [IFoo Number Symbol -&gt; Any])
      baz
      [IFoo Number -&gt; Number])
    (defprotocol&gt; IFoo
      (bar [this] [this n s])
      (baz [this n]))

    ; polymorphic protocol
    ; x is scoped in the methods
    (ann-protocol [[x :variance :covariant]]
      IFooPoly
      bar
      (Fn [(IFooPoly x) -&gt; Any]
          [(IFooPoly x) Number Symbol -&gt; Any])
      baz
      [(IFooPoly x) Number -&gt; Number])
    (defprotocol&gt; IFooPoly
      (bar [this] [this n s])
      (baz [this n]))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1969">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-record">ann-record</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-record dname [field :- type*] opts*)
       (ann-record binder dname [field :- type*] opts*)
</pre>
    <pre id="var-docstr">Annotate record Class name dname with expected fields.
If unqualified, qualify in the current namespace.
Takes an optional type variable binder before the name.

Fields must be specified in the same order as presented 
in defrecord, with exactly the same field names.

Also annotates record factories and constructors.

Binder is a vector of specs. Each spec is a vector
with the variable name as the first entry, followed by
keyword arguments:
- :variance (mandatory)
  The declared variance of the type variable. Possible
  values are :covariant, :contravariant and :invariant.
- :&lt; (optional)
  The upper type bound of the type variable. Defaults to
  Any, or the most general type of the same rank as the
  lower bound.
- :&gt; (optional)
  The lower type bound of the type variable. Defaults to
  Nothing, or the least general type of the same rank as the
  upper bound.

eg. ; a record in the current namespace
    (ann-record MyRecord [a :- Number,
                          b :- Long])

    ; a record in another namespace
    (ann-record another.ns.TheirRecord
                  [str :- String,
                   vec :- (Vec Number)])

    ; a record, polymorphic in a
    (ann-record [[a :variance :covariant]]
                MyPolyRecord
                [str :- String,
                 vec :- (Vec Number)
                 ply :- (Set a)])</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1884">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/atom">atom</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom &amp; args)
</pre>
    <pre id="var-docstr">Like atom, but with optional type annotations.

Same as (atom (ann-form init t) args*)

eg. (atom 1) : (Atom1 (Value 1))
    (atom :- Num, 1) : (Atom1 Num)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/atom&gt;">atom&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom&gt; t init &amp; args)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/atom

Like atom, but creates an Atom1 of type t.

Same as (atom (ann-form init t) args*)

eg. (atom&gt; Number 1)
    (atom&gt; (Vec Any) [])</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.58</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1248">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/cast">cast</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (cast t x)
       (cast t x opt)
</pre>
    <pre id="var-docstr">Cast a value to a type. Returns a new value that conforms
to the given type, otherwise throws an error with blame.

eg. (cast Int 1)
    ;=&gt; 1

    (cast Int nil)
    ; Fail, &lt;blame positive ...&gt;

    ((cast [Int -&gt; Int] identity)
     1)
    ;=&gt; 1

    ((cast [Int -&gt; Int] identity)
     nil)
    ; Fail, &lt;blame negative ...&gt;

    (cast [Int -&gt; Int] nil)
    ; Fail, &lt;blame positive ...&gt;

(defalias Options
  (HMap :optional {:positive (U Sym Str),
                   :negative (U Sym Str)
                   :file (U Str nil)
                   :line (U Int nil)
                   :column (U Int nil)}))

(IFn [Contract Any -&gt; Any]
     [Contract Any Options -&gt; Any]

Options:
- :positive   positive blame, (U Sym Str)
- :negative   negative blame, (U Sym Str)
- :file       file name where contract is checked, (U Str nil)
- :line       line number where contract is checked, (U Int nil)
- :column     column number where contract is checked, (U Int nil)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2373">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/cf">cf</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (cf form)
       (cf form expected)
</pre>
    <pre id="var-docstr">Takes a form and an optional expected type and
returns a human-readable inferred type for that form.
Throws an exception if type checking fails.

Do not use cf inside a typed namespace. cf is intended to be
used at the REPL or within a unit test. Note that testing for
truthiness is not sufficient to unit test a call to cf, as nil
and false are valid type syntax.

cf preserves annotations from previous calls to check-ns or cf,
and keeps any new ones collected during a cf. This is useful for
debugging and experimentation. cf may be less strict than check-ns
with type checker warnings.

eg. (cf 1) 
    ;=&gt; Long

    (cf #(inc %) [Number -&gt; Number])
    ;=&gt; [Number -&gt; Number]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2234">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-form*">check-form*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-form* form)
       (check-form* form expected)
       (check-form* form expected type-provided?)
</pre>
    <pre id="var-docstr">Takes a (quoted) form and optional expected type syntax and
type checks the form. If expected is provided, type-provided?
must be true.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2222">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-form-info">check-form-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-form-info form &amp; opt)
</pre>
    <pre id="var-docstr">Type checks a (quoted) form and returns a map of results from type checking the
form.

Options
- :expected        Type syntax representing the expected type for this form
                   type-provided? option must be true to utilise the type.
- :type-provided?  If true, use the expected type to check the form.
- :profile         Use Timbre to profile the type checker. Timbre must be
                   added as a dependency. Must use the "slim" JAR.
- :file-mapping    If true, return map provides entry :file-mapping, a hash-map
                   of (Map '{:line Int :column Int :file Str} Str).
- :checked-ast     Returns the entire AST for the given form as the :checked-ast entry,
                   annotated with the static types inferred after checking.
                   If a fatal error occurs, mapped to nil.
- :no-eval         If true, don't evaluate :out-form. Removes :result return value.
                   It is highly recommended to evaluate :out-form manually.

Default return map
- :ret             TCResult inferred for the current form
- :out-form        The macroexpanded result of type-checking, if successful. 
- :result          The evaluated result of :out-form, unless :no-eval is provided.
- :ex              If an exception was thrown during evaluation, this key will be present
                   with the exception as the value.
DEPRECATED
- :delayed-errors  A sequence of delayed errors (ex-info instances)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2192">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns">check-ns</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns)
       (check-ns ns-or-syms &amp; opt)
</pre>
    <pre id="var-docstr">Type check a namespace/s (a symbol or Namespace, or collection).
If not provided default to current namespace.
Returns a true value if type checking is successful, otherwise
throws an Exception.

Do not use check-ns within a checked namespace.
It is intended to be used at the REPL or within a unit test.
Suggested idiom for clojure.test: (is (check-ns 'your.ns))

check-ns resets annotations collected from 
previous check-ns calls or cf. A successful check-ns call will
preserve any type annotations collect during that checking run.

Keyword arguments:
- :collect-only  if true, collect type annotations but don't type check code.
                 Useful for debugging purposes.
- :trace         if true, print some basic tracing of the type checker
- :profile       Use Timbre to profile the type checker. Timbre must be
                 added as a dependency. Must use the "slim" JAR.

If providing keyword arguments, the namespace to check must be provided
as the first argument.

Bind clojure.core.typed.util-vars/*verbose-types* to true to print fully qualified types.
Bind clojure.core.typed.util-vars/*verbose-forms* to print full forms in error messages.

eg. (check-ns 'myns.typed)
    ;=&gt; :ok
   
    ; implicitly check current namespace
    (check-ns)
    ;=&gt; :ok

    ; collect but don't check the current namespace
    (check-ns *ns* :collect-only true)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2277">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns-info">check-ns-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns-info)
       (check-ns-info ns-or-syms &amp; opt)
</pre>
    <pre id="var-docstr">Same as check-ns, but returns a map of results from type checking the
namespace.

Options
- :collect-only    Don't type check the given namespace/s, but collect the 
                   top level type annotations like ann, ann-record.
- :type-provided?  If true, use the expected type to check the form
- :profile         Use Timbre to profile the type checker. Timbre must be
                   added as a dependency. Must use the "slim" JAR.
- :file-mapping    If true, return map provides entry :file-mapping, a hash-map
                   of (Map '{:line Int :column Int :file Str} Str).

Default return map
- :delayed-errors  A sequence of delayed errors (ex-info instances)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2257">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-alias-kind">declare-alias-kind</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-alias-kind sym ty)
</pre>
    <pre id="var-docstr">Declare a kind for an alias, similar to declare but on the kind level.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1193">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-datatypes">declare-datatypes</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-datatypes &amp; syms)
</pre>
    <pre id="var-docstr">Declare datatypes, similar to declare but on the type level.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1171">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-names">declare-names</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-names &amp; syms)
</pre>
    <pre id="var-docstr">Declare names, similar to declare but on the type level.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1206">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-protocols">declare-protocols</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-protocols &amp; syms)
</pre>
    <pre id="var-docstr">Declare protocols, similar to declare but on the type level.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1182">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def">def</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def name docstring? :- type? expr)
</pre>
    <pre id="var-docstr">Like clojure.core/def with optional type annotations

NB: in Clojure it is impossible to refer a var called `def` as it is a
special form. Use an alias prefix (eg. `t/def`).

If an annotation is provided, a corresponding `ann` form
is generated, otherwise it expands identically to clojure.core/def

eg. ;same as clojure.core/def
    (def vname 1)
    
    ;with Number `ann`
    (def vname :- Number 1)

    ;doc
    (def vname
      "Docstring"
      :- Long
      1)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def-alias">def-alias</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def-alias sym doc-str t)
       (def-alias sym t)
</pre>
    <pre id="var-docstr">DEPRECATED: use defalias

Define a type alias. Takes an optional doc-string as a second
argument.

Updates the corresponding var with documentation.

eg. (def-alias MyAlias
      "Here is my alias"
      (U nil String))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1284">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def&gt;">def&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def&gt; name docstring? :- type expr)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/def

Like def, but with annotations.

eg. (def&gt; vname :- Long 1)

;doc
(def&gt; vname
  "Docstring"
  :- Long
  1)</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L793">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defalias">defalias</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defalias sym doc-str t)
       (defalias sym t)
</pre>
    <pre id="var-docstr">Define a recursive type alias. Takes an optional doc-string as a second
argument.

Updates the corresponding var with documentation.

eg. (defalias MyAlias
      "Here is my alias"
      (U nil String))

    ;; recursive alias
    (defalias Expr
      (U '{:op ':if :test Expr :then Expr :else Expr}
         '{:op ':const :val Any}))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1317">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defn">defn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn kw-args? name docstring? attr-map? [param :- type *] :- type exprs*)
       (defn kw-args? name docstring? attr-map? ([param :- type *] :- type exprs*) +)
</pre>
    <pre id="var-docstr">Like defn, but expands to clojure.core.typed/fn. If a polymorphic binder is
supplied before the var name, expands to clojure.core.typed/pfn.

eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)

;annotate return
(defn fname [a :- String] :- String ...)

;multi-arity
(defn fname 
  ([a :- String] :- String ...)
  ([a :- String, b :- Number] :- Long ...))

;polymorphic function
(defn :forall [x y]
  fname 
  ([a :- x] :- (Coll y) ...)
  ([a :- Str, b :- y] :- y ...))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defn&gt;">defn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn&gt; name docstring? :- type [param :- type *] exprs*)
       (defn&gt; name docstring? (:- type [param :- type *] exprs*) +)
</pre>
    <pre id="var-docstr">DEPRECATED: Use defn

Like defn, but with annotations. Annotations are mandatory for
parameters and for return type.

eg. (defn&gt; fname :- Integer [a :- Number, b :- (U Symbol nil)] ...)

;annotate return
(defn&gt; fname :- String [a :- String] ...)

;multi-arity
(defn&gt; fname 
  (:- String [a :- String] ...)
  (:- Long   [a :- String, b :- Number] ...))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.57</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L760">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defprotocol">defprotocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defprotocol &amp; body)
</pre>
    <pre id="var-docstr">Like defprotocol, but with optional type annotations.

Omitted annotations default to Any. The first argument
of a protocol cannot be annotated.

Add a binder before the protocol name to define a polymorphic
protocol. A binder before the method name defines a polymorphic
method, however a method binder must not shadow type variables
introduced by a protocol binder.

Return types for each method arity can be annotated.

Unlike clojure.core/defprotocol, successive methods can
have the same arity. Semantically, providing multiple successive
methods of the same arity is the same as just providing the left-most
method. However the types for these methods will be accumulated into
a Fn type.

eg. ;annotate single method
(defprotocol MyProtocol
  (a [this a :- Integer] :- Number))

;polymorphic protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Number))

;multiple types for the same method
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Integer
     [this a :- Long] :- Long
     [this a :- Number] :- Number))

;polymorphic method+protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  ([y] a [this a :- x, b :- y] :- y))
</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defprotocol&gt;">defprotocol&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defprotocol&gt; &amp; body)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/defprotocol

Like defprotocol, but required for type checking
its macroexpansion.

eg. (defprotocol&gt; MyProtocol
      (a [this]))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1097">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/doseq">doseq</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (doseq seq-exprs &amp; body)
</pre>
    <pre id="var-docstr">Like clojure.core/doseq with optional annotations.

:let option uses clojure.core.typed/let

eg.
(doseq [a :- (U nil AnyInteger) [1 nil 2 3]
        :when a]
   (inc a))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L601">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/doseq&gt;">doseq&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (doseq&gt; seq-exprs &amp; body)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/doseq

Like doseq but requires annotation for each loop variable: 
[a [1 2]] becomes [a :- Long [1 2]]

eg.
(doseq&gt; [a :- (U nil AnyInteger) [1 nil 2 3]
         :when a]
   (inc a))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L496">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/dotimes">dotimes</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dotimes bindings &amp; body)
</pre>
    <pre id="var-docstr">Like clojure.core/dotimes, but with optional annotations.

If annotation for binding is omitted, defaults to Int.

eg. (dotimes [_ 100]
      (println "like normal"))

    (dotimes [x :- Num, 100.123]
      (println "like normal" x))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L195">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/dotimes&gt;">dotimes&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dotimes&gt; bindings &amp; body)
</pre>
    <pre id="var-docstr">DEPRECATED: Use clojure.core.typed/dotimes

Like dotimes.

eg. (dotimes&gt; [_ 100]
      (println "like normal"))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L172">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/envs">envs</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (envs)
</pre>
    <pre id="var-docstr">Returns a map of type environments, according to the current state of the
type checker.

Output map:
- :vars      map from var symbols to their verbosely printed types
- :aliases   map from alias var symbols (made with defalias) to their verbosely printed types
- :special-types  a set of Vars that are special to the type checker (like Any, U, I)
</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2337">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/fn">fn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn name? [param :- type* &amp; param :- type * ?] :- type? exprs*)
       (fn name? ([param :- type* &amp; param :- type * ?] :- type? exprs*) +)
</pre>
    <pre id="var-docstr">Like clojure.core/fn, but with optional annotations.

eg. ;these forms are equivalent
    (fn [a] b)
    (fn [a :- Any] b)
    (fn [a :- Any] :- Any b)
    (fn [a] :- Any b)

    ;annotate return
    (fn [a :- String] :- String body)

    ;named fn
    (fn fname [a :- String] :- String body)

    ;rest parameter
    (fn [a :- String &amp; b :- Number *] body)

    ;dotted rest parameter
    (fn [a :- String &amp; b :- Number ... x] body)

    ;multi-arity
    (fn fname 
      ([a :- String] :- String ...)
      ([a :- String, b :- Number] :- String ...))

    ; polymorphic binder
    (fn :forall [x y z]
      fname 
      ([a :- String] :- String ...)
      ([a :- String, b :- Number] :- String ...))
</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/fn&gt;">fn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn&gt; name? :- type? [param :- type* &amp; param :- type * ?] exprs*)
       (fn&gt; name? (:- type? [param :- type* &amp; param :- type * ?] exprs*) +)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/fn

Like fn, but with annotations. Annotations are mandatory
for parameters, with optional annotations for return type.
If fn is named, return type annotation is mandatory.

Suggested idiom: use commas between parameter annotation triples.

eg. (fn&gt; [a :- Number, b :- (U Symbol nil)] ...)

    ;annotate return
    (fn&gt; :- String [a :- String] ...)

    ;named fn
    (fn&gt; fname :- String [a :- String] ...)

    ;multi-arity
    (fn&gt; fname 
      (:- String [a :- String] ...)
      (:- Long   [a :- String, b :- Number] ...))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L717">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/for">for</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (for seq-exprs &amp; maybe-ann-body-expr)
</pre>
    <pre id="var-docstr">Like clojure.core/for with optional type annotations.

All types default to Any.

The :let option uses clojure.core.typed/let.

eg. (for [a :- (U nil Int) [1 nil 2 3]
          :when a]
      :- Number
      (inc a))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L355">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/for&gt;">for&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (for&gt; tk ret-ann seq-exprs body-expr)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/for

Like for but requires annotation for each loop variable: [a [1 2]] becomes [a :- Long [1 2]]
Also requires annotation for return type.

eg. (for&gt; :- Number
      [a :- (U nil AnyInteger) [1 nil 2 3]
       :when a]
      (inc a))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L222">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst">inst</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a polymorphic type with a number of types.

eg. (inst foo-fn t1 t2 t3 ...)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L136">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst-ctor">inst-ctor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst-ctor inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a call to a constructor with a number of types.
First argument must be an immediate call to a constructor.
Returns exactly the instantiatee (the first argument).

eg. (inst-ctor (PolyCtor. a b c)
               t1 t2 ...)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L144">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/install">install</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (install)
       (install features)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang. Takes an optional set of features
to install, defaults to `:all`, which is equivalent to the set of
all features.

Features:
  - :load    Installs typed `load` over `clojure.core/load`, which type checks files
             on the presence of a {:lang :core.typed} metadata entry in the `ns` form.
             The metadata must be inserted in the actual `ns` form saved to disk,
             as it is read directly from the file instead of the current Namespace
             metadata.
  - :eval    Installs typed `eval` over `clojure.core/eval`.
             If `(= :core.typed (:lang (meta *ns*)))` is true, the form will be implicitly
             type checked. The syntax save to disk is ignored however.

eg. (install)            ; installs `load` and `eval`
eg. (install :all)       ; installs `load` and `eval`
eg. (install #{:eval})   ; installs `eval`
eg. (install #{:load})   ; installs `load`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L87">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/into-array&gt;">into-array&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (into-array&gt; cljt coll)
       (into-array&gt; javat cljt coll)
       (into-array&gt; into-array-syn javat cljt coll)
</pre>
    <pre id="var-docstr">Make a Java array with Java class javat and Typed Clojure type
cljt. Resulting array will be of type javat, but elements of coll must be under
cljt. cljt should be a subtype of javat (the same or more specific).

*Temporary hack*
into-array-syn is exactly the syntax to put as the first argument to into-array.
Calling resolve on this syntax should give the correct class.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1666">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/let">let</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (let [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/let but supports optional type annotations.

eg. (let [a :- Type, b
          a2 1.2]
      body)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/letfn&gt;">letfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (letfn&gt; [fn-spec-or-annotation*] expr*)
</pre>
    <pre id="var-docstr">Like letfn, but each function spec must be annotated.

eg. (letfn&gt; [a :- [Number -&gt; Number]
             (a [b] 2)

             c :- [Symbol -&gt; nil]
             (c [s] nil)]
      ...)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L825">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/load-if-needed">load-if-needed</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (load-if-needed)
</pre>
    <pre id="var-docstr">Load and initialize all of core.typed if not already</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L53">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/loop">loop</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/loop, and supports optional type annotations.
Arguments default to a generalised type based on the initial value.

eg. (loop [a :- Number 1
           b :- (U nil Number) nil]
      ...)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/loop&gt;">loop&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop&gt; [binding :- type init*] exprs*)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/loop

Like loop, except loop variables require annotation.

Suggested idiom: use a comma between the type and the initial
expression.

eg. (loop&gt; [a :- Number, 1
            b :- (U nil Number), nil]
      ...)</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1115">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/method-type">method-type</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (method-type mname)
</pre>
    <pre id="var-docstr">Given a method symbol, print the core.typed types assigned to it.
Intended for use at the REPL.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L66">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/nilable-param">nilable-param</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (nilable-param msym mmap)
</pre>
    <pre id="var-docstr">Override which parameters in qualified method msym may accept
nilable values. If the parameter is a parameterised type or
an Array, this also declares the parameterised types and the Array type as nilable.

mmap is a map mapping arity parameter number to a set of parameter
positions (integers). If the map contains the key :all then this overrides
other entries. The key can also be :all, which declares all parameters nilable.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1705">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/non-nil-return">non-nil-return</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (non-nil-return msym arities)
</pre>
    <pre id="var-docstr">Override the return type of fully qualified method msym to be non-nil.
Takes a set of relevant arities,
represented by the number of parameters it takes (rest parameter counts as one),
or :all which overrides all arities.

eg. ; must use full class name
    (non-nil-return java.lang.Class/getDeclaredMethod :all)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1688">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-constructor">override-constructor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-constructor ctorsym typesyn)
</pre>
    <pre id="var-docstr">Override all constructors for Class ctorsym with type.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2098">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-method">override-method</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-method methodsym typesyn)
</pre>
    <pre id="var-docstr">Override type for qualified method methodsym.

methodsym identifies the method to override and should be a
namespace-qualified symbol in the form &lt;class&gt;/&lt;method-name&gt;.
The class name needs to be fully qualified.

typesyn uses the same annotation syntax as functions.

Use non-nil-return instead of override-method if you want to
declare that a method can never return nil.

Example:

  (override-method java.util.Properties/stringPropertyNames
                   [-&gt; (java.util.Set String)])

This overrides the return type of method stringPropertyNames
of class java.util.Properties to be (java.util.Set String).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2109">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/pfn&gt;">pfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (pfn&gt; &amp; forms)
</pre>
    <pre id="var-docstr">Define a polymorphic typed anonymous function.
(pfn&gt; name? [binder+] :- type? [[param :- type]* &amp; [param :- type *]?] exprs*)
(pfn&gt; name? [binder+] (:- type? [[param :- type]* &amp; [param :- type *]?] exprs*)+)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L708">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/pred">pred</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (pred t)
</pre>
    <pre id="var-docstr">Generate a flat (runtime) predicate for type that returns true if the
argument is a subtype of the type, otherwise false.

The current type variable and dotted type variable scope is cleared before parsing.

eg. ((pred Number) 1)
    ;=&gt; true</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2358">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-env">print-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-env debug-str)
</pre>
    <pre id="var-docstr">During type checking, print the type environment to *out*,
preceeded by literal string debug-str.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1719">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-filterset">print-filterset</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-filterset debug-string frm)
</pre>
    <pre id="var-docstr">During type checking, print the filter set attached to form, 
preceeded by literal string debug-string.
Returns nil.

eg. (let [s (seq (get-a-seqable))]
      (print-filterset "Here now" s))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L113">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ref">ref</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref &amp; args)
</pre>
    <pre id="var-docstr">Like ref, but with optional type annotations.

Same as (ref (ann-form init t) args*)

eg. (ref 1) : (Ref1 (Value 1))
    (ref :- Num, 1) : (Ref1 Num)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ref&gt;">ref&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref&gt; t init &amp; args)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/ref

Like ref, but creates a Ref1 of type t.

Same as (ref (ann-form init t) args*)

eg. (ref&gt; Number 1)
    (ref&gt; (Vec Any) [])</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.58</span><br /></span>
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1266">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/reset-caches">reset-caches</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reset-caches)
</pre>
    <pre id="var-docstr">Reset internal type caches.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L58">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/statistics">statistics</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (statistics nsyms)
</pre>
    <pre id="var-docstr">Takes a collection of namespace symbols and returns a map mapping the namespace
symbols to a map of data</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2320">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/tc-ignore">tc-ignore</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (tc-ignore &amp; body)
</pre>
    <pre id="var-docstr">Ignore forms in body during type checking</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/typed-deps">typed-deps</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (typed-deps &amp; args)
</pre>
    <pre id="var-docstr">Declare namespaces which should be checked before the current namespace.
Accepts any number of symbols. Only has effect via check-ns.

eg. (typed-deps clojure.core.typed.holes
                myns.types)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2137">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/untyped-var">untyped-var</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (untyped-var varsym typesyn)
</pre>
    <pre id="var-docstr">Check a given var has the specified type at runtime.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L1731">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/var-coverage">var-coverage</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (var-coverage)
       (var-coverage nsyms-or-nsym)
</pre>
    <pre id="var-docstr">Summarises annotated var coverage statistics to *out*
for namespaces nsyms, a collection of symbols or a symbol/namespace.
Defaults to the current namespace if no argument provided.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2328">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/var&gt;">var&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (var&gt; sym)
</pre>
    <pre id="var-docstr">Like var, but resolves at runtime like ns-resolve and is understood by
the type checker. sym must be fully qualified (without aliases).

eg. (var&gt; clojure.core/+)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2166">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (warn-on-unannotated-vars)
</pre>
    <pre id="var-docstr">Allow unannotated vars in the current namespace. 

Emits a warning instead of a type error when checking
a def without a corresponding expected type.

Disables automatic inference of `def` expressions.

eg. (warn-on-unannotated-vars)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed.clj#L2180">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/when-let-fail">when-let-fail</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (when-let-fail b &amp; body)
</pre>
    <pre id="var-docstr">Like when-let, but fails if the binding yields a false value.</pre>
    
    
    
  </div>
</div>
<br />
<h2 id="clojure.core.typed.async">clojure.core.typed.async</h2>
<pre id="namespace-docstr">This namespace contains annotations and helper macros for type
checking core.async code. Ensure clojure.core.async is require'd
before performing type checking.

go
  use go

chan
  use chan

buffer
  use buffer (similar for other buffer constructors)
</pre>


<br />



<br />
<h2 id="clojure.core.typed.base-env-common">clojure.core.typed.base-env-common</h2>
<pre id="namespace-docstr">Utilities for all implementations of the type checker</pre>


<br />



<br />
<h2 id="clojure.core.typed.check-form-cljs">clojure.core.typed.check-form-cljs</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check-form-cljs/check-form-cljs">check-form-cljs</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-form-cljs form expected expected-provided?)
</pre>
    <pre id="var-docstr">Check a single form with an optional expected type.
Intended to be called from Clojure. For evaluation at the Clojurescript
REPL see cf.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/935e7c9277a1954cdd011907cb5a8abe3134b05e/module-check/src/main/clojure/clojure/core/typed/check_form_cljs.clj#L25">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check-ns-clj">clojure.core.typed.check-ns-clj</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check-ns-clj/check-ns-info">check-ns-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns-info ns-or-syms &amp; opt)
</pre>
    <pre id="var-docstr">Same as check-ns, but returns a map of results from type checking the
namespace.

Options
- :collect-only    Don't type check the given namespace/s, but collect the 
                   top level type annotations like ann, ann-record.
- :type-provided?  If true, use the expected type to check the form
- :profile         Use Timbre to profile the type checker. Timbre must be
                   added as a dependency.
- :file-mapping    If true, return map provides entry :file-mapping, a hash-map
                   of (Map '{:line Int :column Int :file Str} Str).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/7d7264105b8f1d07915413cb75743a4f6b847dc4/module-check/src/main/clojure/clojure/core/typed/check_ns_clj.clj#L6">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check.def">clojure.core.typed.check.def</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.def/add-checks-normal-def">add-checks-normal-def</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (add-checks-normal-def check-fn expr expected)
</pre>
    <pre id="var-docstr">Add runtime checks to a def with an initial value.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/def.clj#L123">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.def/check-def">check-def</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-def check-fn {:keys [var init env], :as expr} expected)
</pre>
    <pre id="var-docstr">Check a def. If it is a declare or a defmacro, don't try and check it.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/def.clj#L111">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.def/check-defmacro-or-declare">check-defmacro-or-declare</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-defmacro-or-declare expr expected)
</pre>
    <pre id="var-docstr">To check a defmacro or declare, just assign it the most general
Var type and ignore the body.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/def.clj#L101">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.def/check-normal-def">check-normal-def</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-normal-def check-fn {:keys [init env], :as expr} &amp; [expected])
</pre>
    <pre id="var-docstr">Checks a def that isn't a macro definition.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/def.clj#L22">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.def/defmacro-or-declare?">defmacro-or-declare?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (defmacro-or-declare? {:keys [var], :as expr})
</pre>
    <pre id="var-docstr">Returns true if this :def AST originally a defmacro or declare.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/def.clj#L95">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check.fn-methods">clojure.core.typed.check.fn-methods</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.fn-methods/check-fni">check-fni</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-fni expected mthods {:keys [recur-target-fn validate-expected-fn self-name], :as opt})
</pre>
    <pre id="var-docstr">Check a vector of :method AST nodes mthods against
an expected type that is a possibly-polymorphic function
intersection.

Returns a vector in the same order as the passed in methods,
but each method replaced with a vector of type checked methods.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/488c9279bd44cee8eacd5167b1dc4773943a8666/module-check/src/main/clojure/clojure/core/typed/check/fn_methods.clj#L78">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.fn-methods/expected-for-method">expected-for-method</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (expected-for-method {:keys [fixed-arity], :as method} {:keys [dom rest drest kws], :as f})
</pre>
    <pre id="var-docstr">Takes a :method AST node and a single Function arity type,
and returns the Function if the :method node should be checked
against the Function, otherwise returns nil.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/488c9279bd44cee8eacd5167b1dc4773943a8666/module-check/src/main/clojure/clojure/core/typed/check/fn_methods.clj#L39">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check.monitor">clojure.core.typed.check.monitor</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.monitor/check-monitor">check-monitor</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-monitor check {:keys [target], :as expr} expected)
</pre>
    <pre id="var-docstr">monitor-enter and monitor-exit both take any object and return nil</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/81a3bc793db822eaeee5d59f1498fbaa24639cdd/module-check/src/main/clojure/clojure/core/typed/check/monitor.clj#L11">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check.special.ann-form">clojure.core.typed.check.special.ann-form</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.special.ann-form/add-checks-ann-form">add-checks-ann-form</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (add-checks-ann-form check {:keys [statements env], frm :ret, :as expr} expected)
</pre>
    <pre id="var-docstr">Add runtime checks to an ann-form expression. Propagates its annotation
inwards to the inner expression.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/special/ann_form.clj#L61">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.special.ann-form/ann-form-annotation">ann-form-annotation</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ann-form-annotation {:keys [statements], :as expr})
</pre>
    <pre id="var-docstr">Return the raw type annotation from the ann-form expression.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/special/ann_form.clj#L15">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.special.ann-form/check-ann-form">check-ann-form</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ann-form check {:keys [statements env], frm :ret, :as expr} expected)
</pre>
    <pre id="var-docstr">Type check an ann-form expression. Propagates its annotation
inwards to the inner expression.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/special/ann_form.clj#L38">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.special.ann-form/parse-annotation">parse-annotation</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (parse-annotation tsyn {:keys [env], :as expr})
</pre>
    <pre id="var-docstr">Parse the raw type annotation tsyn in the context of expr</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/check/special/ann_form.clj#L30">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check.value">clojure.core.typed.check.value</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.value/check-value">check-value</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-value {:keys [val], :as expr} expected quoted?)
</pre>
    <pre id="var-docstr">Given a :const node and an expected type returns a new :const
node annotated with its type.

quoted? should be true if this :const node is nested inside a
:quote node, otherwise should be false</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/afed234808448bcdd851c2b15e8baf6eb8853b36/module-check/src/main/clojure/clojure/core/typed/check/value.clj#L47">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check.value/unquote-val">unquote-val</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unquote-val val)
</pre>
    <pre id="var-docstr">Convert the syntax representation of a unevaluated value to
an actual evaluated value.

eg. ['a] is represented as [(quote a)] and evaluates to [a]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/afed234808448bcdd851c2b15e8baf6eb8853b36/module-check/src/main/clojure/clojure/core/typed/check/value.clj#L24">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.collect-utils">clojure.core.typed.collect-utils</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.collect-utils/collect-ns*">collect-ns*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (collect-ns* nsym {:keys [ast-for-ns collect-asts collect-ns]})
</pre>
    <pre id="var-docstr">Collect type annotations and dependency information
for namespace symbol nsym, and recursively check 
declared typed namespace dependencies.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/afed234808448bcdd851c2b15e8baf6eb8853b36/module-check/src/main/clojure/clojure/core/typed/collect_utils.clj#L53">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.contract">clojure.core.typed.contract</h2>
<pre id="namespace-docstr">A contract system a la racket/contract.

Main entry point is the `contract` macro.</pre>


<br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/Blame">Blame</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[positive negative name contract file line column]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/CheckedISeq">CheckedISeq</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[s c b]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ISeq, clojure.lang.Sequential</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/Contract">Contract</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[name first-order projection flat?]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/-&gt;Blame">-&gt;Blame</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;Blame positive negative name contract file line column)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.contract.Blame.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L44">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/-&gt;CheckedISeq">-&gt;CheckedISeq</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;CheckedISeq s c b)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.contract.CheckedISeq.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L279">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/-&gt;Contract">-&gt;Contract</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;Contract name first-order projection flat?)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.contract.Contract.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L29">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/and-c">and-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (and-c &amp; cs)
</pre>
    <pre id="var-docstr">Returns a contract that ensures a value passes each contract `cs`.

At most *one* higher-order contract may be passed to `and-c`, and
any number of flat contracts.

[Contract * -&gt; Contract]

eg. (and-c (instance-c Boolean) true-c)  ;; (I Boolean true)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L381">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/any-c">any-c</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Contract that allows any value.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L189">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/contract">contract</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (contract c x)
       (contract c x b)
</pre>
    <pre id="var-docstr">Check a contract against a value, with an optional Blame object.

(IFn [Contract Any -&gt; Any]
     [Contract Any Blame -&gt; Any])</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L123">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/count-range-c">count-range-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (count-range-c lower)
       (count-range-c lower upper)
</pre>
    <pre id="var-docstr">Returns a flat contract that allows values with `count`
greater-or-equal-to lower, and less-or-equal-to upper.
Upper can be nil for positive infinity.

(IFn [Int -&gt; Contract]
     [Int (U nil Int) -&gt; Contract])

eg. (count-range-c 0 10)
    (count-range-c 0 nil)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L196">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/equiv-c">equiv-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (equiv-c y)
</pre>
    <pre id="var-docstr">Returns a flat contract that returns true if a value is `=`
to y.

[Any -&gt; Contract]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L217">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/false-c">false-c</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Contract that checks for `false`.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L184">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/flat-val-c">flat-val-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (flat-val-c name pred)
</pre>
    <pre id="var-docstr">Contract generation for flat predicates.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L169">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/hmap-c">hmap-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (hmap-c &amp; {:keys [mandatory optional absent-keys complete?], :or {absent-keys #{}, mandatory {}, optional {}, complete? false}})
</pre>
    <pre id="var-docstr">Takes a map of mandatory and optional entry contracts,
a set of absent keys, and :complete? true if this is a fully
specified map. Intended to work with keyword keys, but should
work with any keys looked up via =.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L422">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/identical-c">identical-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (identical-c y)
</pre>
    <pre id="var-docstr">Returns a flat contract that returns true if a value is `identical?`
to y.

[Any -&gt; Contract]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L228">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/ifn-c">ifn-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ifn-c cs c2)
</pre>
    <pre id="var-docstr">Returns a function contract that checks a function has
fixed domain that passes contracts `cs` and return value
that passes contact `c2`.

[(Vec Contract) Contract -&gt; Contract]

eg. (ifn-c [int-c] int-c)  ;; [Int -&gt; Int] contract</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L240">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/instance-c">instance-c</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (instance-c c)
</pre>
    <pre id="var-docstr">Flat contracts for instance? checks on Class's.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L159">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/int-c">int-c</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Flat contract for values that pass `integer?`.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L154">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/make-blame">make-blame</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (make-blame &amp; {:as bls})
</pre>
    <pre id="var-docstr">Make a new blame object.

Keyword arguments:
- :message    A string message, String
- :positive   Positive blame party, (U String Symbol)
- :negative   Negative blame party, (U String Symbol)
- :file       File that contains contract, (U Str nil)
- :line       Line where contract occurs, (U Int nil)
- :column     Column where contract occurs, (U Int nil)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L110">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/make-contract">make-contract</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (make-contract &amp; {:keys [name first-order projection flat?], :or {flat? false}})
</pre>
    <pre id="var-docstr">Make a new contract.

Keyword arguments: (see Contract datatype for more details)
- :name         Name of the contract, (U Symbol String)
- :first-order  First-order predicate for this contract, [Any -&gt; Any]
- :projection   Curried function taking blame and the value to check,
                and returns a new checked value, or throws blame.
                [Blame -&gt; [Any -&gt; Any]]
- :flat?        True if this is a flat contract, Boolean</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L69">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/make-flat-contract">make-flat-contract</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (make-flat-contract &amp; args)
</pre>
    <pre id="var-docstr">Calls `make-contract` but also passes `:flat? true` as the first arguments.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L98">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/map-&gt;Blame">map-&gt;Blame</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;Blame m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.typed.contract.Blame, taking a map of keywords to field values.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L44">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/map-&gt;Contract">map-&gt;Contract</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;Contract m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.typed.contract.Contract, taking a map of keywords to field values.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L29">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/nil-c">nil-c</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Contract that checks for `nil`.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L178">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/or-c">or-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (or-c &amp; cs)
</pre>
    <pre id="var-docstr">Returns a contract that checks a value passes at least
one of the contracts `cs`.

Any number of flat contracts may be passed to or-c. However,
if more than one higher-order contract is provided, each time
this contract is used, at most *one* may pass its first-order
predicate.

For example, (or-c (ifn-c [int-c] int-c) (ifn-c [] int-c))
cannot be checked against `clojure.core/+` because
the first-order check for both contracts (`ifn?`) passes.

[Contract * -&gt; Contract]

eg. (or-c int-c nil-c) ;; (U Int nil)
    (or-c int-c (ifn-c [int-c] int-c)) ;; (U Int [Int -&gt; Int])
</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L327">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/seqable-c">seqable-c</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (seqable-c c)
</pre>
    <pre id="var-docstr">Alpha - subject to change.

Returns a contract that checks Seqable things.

[Contract -&gt; Contract]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L307">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/swap-blame">swap-blame</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (swap-blame x)
</pre>
    <pre id="var-docstr">Swap a blame object's blame parties.

[Blame -&gt; Blame]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L142">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/throw-blame">throw-blame</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (throw-blame {:keys [message positive negative file line column], :as b})
</pre>
    <pre id="var-docstr">Throw a blame object

[Blame -&gt; Nothing]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L47">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.contract/true-c">true-c</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Contract that checks for `true`.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/a34bcd127ebe2db79748f87e30c67551ccdc4242/module-rt/src/main/clojure/clojure/core/typed/contract.clj#L181">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.current-impl">clojure.core.typed.current-impl</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.current-impl/create-env">create-env</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (create-env n)
</pre>
    <pre id="var-docstr">For name n, creates defs for {n}, {n}-kw, add-{n},
and reset-{n}!</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0947387913babb0e8db52b560a3c0e42b45cb40b/module-rt/src/main/clojure/clojure/core/typed/current_impl.clj#L7">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.hole">clojure.core.typed.hole</h2>
<pre id="namespace-docstr">This namespace contains easy tools for hole driven development</pre>


<span id="see-also">See also: 
  <span id="see-also-link">
    <a href="http://matthew.brecknell.net/post/hole-driven-haskell/">Hole Driven Development</a>
  </span><br />
</span><br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/NoisyHole">NoisyHole</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NoisyHole)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.hole.NoisyHole.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/hole.clj#L17">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/noisy-hole">noisy-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (noisy-hole)
</pre>
    <pre id="var-docstr">A noisy hole. The type system will complain when
(noisy-hole) is used in positions that expect a type
more specific than Object or Any.
Use (noisy-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/hole.clj#L20">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/silent-hole">silent-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (silent-hole)
</pre>
    <pre id="var-docstr">A silent hole. (silent-hole) passes for any other type
when type checking.
Use (silent-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/hole.clj#L8">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.lang">clojure.core.typed.lang</h2>
<pre id="namespace-docstr">Extensible languages in Clojure, a la Racket's #lang.

This is a simple library that monkey patches clojure.core/load
to be extensible to different backends.

`monkey-patch-extensible-load` does the actual monkey-patching and
must be called explicitly.

`lang-dispatch` is a map from keywords to alternative `load` functions
(of type [String -&gt; nil]). The corresponding function will be used to
load a file according its :lang metadata entry in the `ns` form.

To add a new implementation, use
  (alter-var-root lang-dispatch assoc :new-impl my-load)

eg. A file with a `ns` form
      (ns fancy-ns-form
        {:lang :new-impl})
    will use `my-load` to load the file.
</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/default-eval">default-eval</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (default-eval form)
</pre>
    <pre id="var-docstr">Roughly equivalent to clojure.core/eval.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L37">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/default-load1">default-load1</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (default-load1 base-resource-path)
</pre>
    <pre id="var-docstr">Roughly equivalent to clojure.core/load.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L31">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/extensible-eval">extensible-eval</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (extensible-eval form)
</pre>
    <pre id="var-docstr">Evaluates the form data structure (not text!) and returns the result.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L80">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/extensible-load">extensible-load</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (extensible-load &amp; paths)
</pre>
    <pre id="var-docstr">Loads Clojure code from resources in classpath. A path is interpreted as
classpath-relative if it begins with a slash or relative to the root
directory for the current namespace otherwise.</pre>
    <span class="var-added"><span id="content">Added in Gradual Typing version 1.0</span><br /></span>
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L58">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/file-lang">file-lang</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (file-lang res)
</pre>
    <pre id="var-docstr">Returns the :lang entry in ns form in the given namespace.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L43">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/install">install</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (install)
       (install features)
</pre>
    <pre id="var-docstr">A no-argument function that installs extensible `eval` and `load`
alternatives that respect :lang ns metadata</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L106">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/lang-dispatch">lang-dispatch</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A map from :lang entries to their corresponding `load` and `eval` alternatives.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L26">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/monkey-patch-extensible-eval">monkey-patch-extensible-eval</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A no-argument function that installs the extensible `eval` function
over clojure.core/eval.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L98">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/monkey-patch-extensible-load">monkey-patch-extensible-load</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A no-argument function that installs the extensible `load` function
over clojure.core/load.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L89">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.lang/ns-lang">ns-lang</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ns-lang ns)
</pre>
    <pre id="var-docstr">Returns the :lang value in the give Namespace's metadata.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/lang.clj#L52">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.load">clojure.core.typed.load</h2>
<pre id="namespace-docstr">Front end for actual implementation in clojure.core.typed.load1.

Indirection is necessary to delay loading core.typed as long as possible.</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load/install">install</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (install)
       (install features)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang. Takes an optional set of features
to install, defaults to #{:load :eval}.

Features:
  - :load    Installs typed `load` over `clojure.core/load`
  - :eval    Installs typed `eval` over `clojure.core/eval`

eg. (install)            ; installs `load` and `eval`
eg. (install #{:eval})   ; installs `eval`
eg. (install #{:eval})   ; installs `load`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed/load.clj#L68">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load/install-typed-load">install-typed-load</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (install-typed-load)
</pre>
    <pre id="var-docstr">Extend the :lang dispatch table with the :core.typed language</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed/load.clj#L47">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load/load-typed-file">load-typed-file</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (load-typed-file filename)
       (load-typed-file filename env)
       (load-typed-file filename env opts)
</pre>
    <pre id="var-docstr">Loads a whole typed namespace, returns nil. Assumes the file is typed.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed/load.clj#L12">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load/monkey-patch-typed-eval">monkey-patch-typed-eval</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (monkey-patch-typed-eval)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang, and monkey patch `eval`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed/load.clj#L61">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load/monkey-patch-typed-load">monkey-patch-typed-load</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (monkey-patch-typed-load)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang, and monkey patch `load`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed/load.clj#L54">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load/typed-load1">typed-load1</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (typed-load1 base-resource-path)
</pre>
    <pre id="var-docstr">Checks if the given file is typed, and loads it with core.typed if so,
otherwise with clojure.core/load</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-rt/src/main/clojure/clojure/core/typed/load.clj#L32">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.load1">clojure.core.typed.load1</h2>
<pre id="namespace-docstr">Implementation of clojure.core.typed.load.</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load1/install">install</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (install)
       (install features)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang. Takes an optional set of features
to install, defaults to #{:load :eval}.

Features:
  - :load    Installs typed `load` over `clojure.core/load`
  - :eval    Installs typed `eval` over `clojure.core/eval`

eg. (install)            ; installs `load` and `eval`
eg. (install #{:eval})   ; installs `eval`
eg. (install #{:eval})   ; installs `load`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/load1.clj#L116">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load1/install-typed-load">install-typed-load</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (install-typed-load)
</pre>
    <pre id="var-docstr">Extend the :lang dispatch table with the :core.typed language</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/load1.clj#L89">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load1/load-typed-file">load-typed-file</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (load-typed-file filename)
       (load-typed-file filename env)
       (load-typed-file filename env opts)
</pre>
    <pre id="var-docstr">Loads a whole typed namespace, returns nil. Assumes the file is typed.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/load1.clj#L24">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load1/monkey-patch-typed-eval">monkey-patch-typed-eval</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (monkey-patch-typed-eval)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang, and monkey patch `eval`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/load1.clj#L108">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load1/monkey-patch-typed-load">monkey-patch-typed-load</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (monkey-patch-typed-load)
</pre>
    <pre id="var-docstr">Install the :core.typed :lang, and monkey patch `load`</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/load1.clj#L100">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.load1/typed-load1">typed-load1</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (typed-load1 base-resource-path)
</pre>
    <pre id="var-docstr">Checks if the given file is typed, and loads it with core.typed if so,
otherwise with clojure.core/load</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0e71ef860aeec4554ea3292741658f48000a303b/module-check/src/main/clojure/clojure/core/typed/load1.clj#L66">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.macros">clojure.core.typed.macros</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/ann-form">ann-form</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-form form ty)
</pre>
    <pre id="var-docstr">Annotate a form with an expected type.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L130">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/atom">atom</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom &amp; args)
</pre>
    <pre id="var-docstr">Like atom, but with optional type annotations.

Same as (atom (ann-form init t) args*)

eg. (atom 1) : (Atom1 (Value 1))
    (atom :- Num, 1) : (Atom1 Num)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L198">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/def">def</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def name docstring? :- type? expr)
</pre>
    <pre id="var-docstr">Like clojure.core/def with optional type annotations

NB: in Clojure it is impossible to refer a var called `def` as it is a
special form. Use an alias prefix (eg. `t/def`).

If an annotation is provided, a corresponding `ann` form
is generated, otherwise it expands identically to clojure.core/def

eg. ;same as clojure.core/def
    (def vname 1)
    
    ;with Number `ann`
    (def vname :- Number 1)

    ;doc
    (def vname
      "Docstring"
      :- Long
      1)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L22">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/defn">defn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn kw-args? name docstring? attr-map? [param :- type *] :- type exprs*)
       (defn kw-args? name docstring? attr-map? ([param :- type *] :- type exprs*) +)
</pre>
    <pre id="var-docstr">Like defn, but expands to clojure.core.typed/fn. If a polymorphic binder is
supplied before the var name, expands to clojure.core.typed/pfn.

eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)

;annotate return
(defn fname [a :- String] :- String ...)

;multi-arity
(defn fname 
  ([a :- String] :- String ...)
  ([a :- String, b :- Number] :- Long ...))

;polymorphic function
(defn :forall [x y]
  fname 
  ([a :- x] :- (Coll y) ...)
  ([a :- Str, b :- y] :- y ...))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L228">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/defprotocol">defprotocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defprotocol &amp; body)
</pre>
    <pre id="var-docstr">Like defprotocol, but with optional type annotations.

Omitted annotations default to Any. The first argument
of a protocol cannot be annotated.

Add a binder before the protocol name to define a polymorphic
protocol. A binder before the method name defines a polymorphic
method, however a method binder must not shadow type variables
introduced by a protocol binder.

Return types for each method arity can be annotated.

Unlike clojure.core/defprotocol, successive methods can
have the same arity. Semantically, providing multiple successive
methods of the same arity is the same as just providing the left-most
method. However the types for these methods will be accumulated into
a Fn type.

eg. ;annotate single method
(defprotocol MyProtocol
  (a [this a :- Integer] :- Number))

;polymorphic protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Number))

;multiple types for the same method
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Integer
     [this a :- Long] :- Long
     [this a :- Number] :- Number))

;polymorphic method+protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  ([y] a [this a :- x, b :- y] :- y))
</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L138">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/fn">fn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn name? [param :- type* &amp; param :- type * ?] :- type? exprs*)
       (fn name? ([param :- type* &amp; param :- type * ?] :- type? exprs*) +)
</pre>
    <pre id="var-docstr">Like clojure.core/fn, but with optional annotations.

eg. ;these forms are equivalent
    (fn [a] b)
    (fn [a :- Any] b)
    (fn [a :- Any] :- Any b)
    (fn [a] :- Any b)

    ;annotate return
    (fn [a :- String] :- String body)

    ;named fn
    (fn fname [a :- String] :- String body)

    ;rest parameter
    (fn [a :- String &amp; b :- Number *] body)

    ;dotted rest parameter
    (fn [a :- String &amp; b :- Number ... x] body)

    ;multi-arity
    (fn fname 
      ([a :- String] :- String ...)
      ([a :- String, b :- Number] :- String ...))

    ; polymorphic binder
    (fn :forall [x y z]
      fname 
      ([a :- String] :- String ...)
      ([a :- String, b :- Number] :- String ...))
</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L64">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/let">let</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (let [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/let but supports optional type annotations.

eg. (let [a :- Type, b
          a2 1.2]
      body)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L118">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/loop">loop</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/loop, and supports optional type annotations.
Arguments default to a generalised type based on the initial value.

eg. (loop [a :- Number 1
           b :- (U nil Number) nil]
      ...)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L102">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/parse-colon">parse-colon</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (parse-colon fdecl name)
</pre>
    <pre id="var-docstr">Returns a vector of [provided? t args]</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L14">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/ref">ref</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref &amp; args)
</pre>
    <pre id="var-docstr">Like ref, but with optional type annotations.

Same as (ref (ann-form init t) args*)

eg. (ref 1) : (Ref1 (Value 1))
    (ref :- Num, 1) : (Ref1 Num)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L213">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/tc-ignore">tc-ignore</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (tc-ignore &amp; body)
</pre>
    <pre id="var-docstr">Ignore forms in body during type checking</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L184">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/when-let-fail">when-let-fail</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (when-let-fail b &amp; body)
</pre>
    <pre id="var-docstr">Like when-let, but fails if the binding yields a false value.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/73d6be1f8024bf40b61015e65de0f94fb8e0597e/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L191">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.runtime-check">clojure.core.typed.runtime-check</h2>
<pre id="namespace-docstr">Adds runtime checks where annotations are instead of type checking</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.runtime-check/check">check</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check expr)
       (check expr expected)
</pre>
    <pre id="var-docstr">Add runtime checks to the output AST, propagating just enough types
for immediate ann-form expressions to propagate to fn expected types.

Static checking is disabled, outside ill-formed types.

Unsafe contracts can be generated, and contract generation cannot fail.

Assumes collect-expr is already called on this AST.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/868a4ff39a2ce57658126c6facd4d558fc3df246/module-check/src/main/clojure/clojure/core/typed/runtime_check.clj#L9">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.statistics">clojure.core.typed.statistics</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.statistics/statistics">statistics</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (statistics nsyms)
</pre>
    <pre id="var-docstr">Takes a collection of namespace symbols and returns a map mapping the namespace
symbols to a map of data</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/0947387913babb0e8db52b560a3c0e42b45cb40b/module-check/src/main/clojure/clojure/core/typed/statistics.clj#L22">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.util-vars">clojure.core.typed.util-vars</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*trace-checker*">*trace-checker*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print tracing information during type checking.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/e7ec013923bcb740c52baa9c61e312df0decab20/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L32">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*verbose-forms*">*verbose-forms*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print complete forms in error messages. Bind
around a type checking form like cf or check-ns.

eg.
(binding [*verbose-forms* true]
  (cf ['deep ['deep ['deep ['deep]]]] Number))
;=&gt; &lt;full form in error&gt;</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/e7ec013923bcb740c52baa9c61e312df0decab20/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L20">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*verbose-types*">*verbose-types*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print fully qualified types in error messages
and return values. Bind around a type checking form like 
cf or check-ns.

eg. 
(binding [*verbose-types* true] 
  (cf 1 Number))
;=&gt; java.lang.Number</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.typed/blob/e7ec013923bcb740c52baa9c61e312df0decab20/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L7">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2016 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>