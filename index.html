<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>clojure.core.typed - Gradual Typing 0.2.73 API documentation</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">core.typed API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">Gradual Typing</span> <span id="version">0.2.73</span> API</span><br />
    <ul>
      <li><a class="wiki_link" href="index.html">Overview</a></li>
      <li><a class="wiki_link" href="api-index.html">API Index</a></li>
    </ul>
    
    
    <a href="http://clojure.org" class="wiki_link">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0" style="margin-top: 3px;">Overview</a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#var-section" style="margin-top: 3px;">Vars and Functions</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ASeq">ASeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/AVec">AVec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Agent1">Agent1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Agent2">Agent2</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/All">All</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Any">Any</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/AnyInteger">AnyInteger</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/AnyValue">AnyValue</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Assoc">Assoc</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Atom1">Atom1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Atom2">Atom2</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/BlockingDeref">BlockingDeref</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Bool">Bool</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Coll">Coll</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/CountRange">CountRange</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Delay">Delay</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Deref">Deref</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Difference">Difference</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Dissoc">Dissoc</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/EmptyCount">EmptyCount</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/EmptySeqable">EmptySeqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ExInfo">ExInfo</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ExactCount">ExactCount</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Fn">Fn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Future">Future</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Get">Get</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/HMap">HMap</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/HSeq">HSeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/HSequential">HSequential</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/HSet">HSet</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/HVec">HVec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Hierarchy">Hierarchy</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/I">I</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/IFn">IFn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Id">Id</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Int">Int</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Keyword">Keyword</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Kw">Kw</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/List">List</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Map">Map</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Multi">Multi</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Namespace">Namespace</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Nilable">Nilable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NilableNonEmptyASeq">NilableNonEmptyASeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NilableNonEmptySeq">NilableNonEmptySeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyASeq">NonEmptyASeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyAVec">NonEmptyAVec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyColl">NonEmptyColl</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyCount">NonEmptyCount</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyLazySeq">NonEmptyLazySeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptySeq">NonEmptySeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptySeqable">NonEmptySeqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/NonEmptyVec">NonEmptyVec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Nothing">Nothing</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Num">Num</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Option">Option</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Pred">Pred</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Promise">Promise</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Proxy">Proxy</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Rec">Rec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Ref1">Ref1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Ref2">Ref2</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Reversible">Reversible</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Seq">Seq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Seqable">Seqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Sequential">Sequential</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/SequentialSeq">SequentialSeq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/SequentialSeqable">SequentialSeqable</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Set">Set</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/SortedSet">SortedSet</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Stack">Stack</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Str">Str</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Sym">Sym</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Symbol">Symbol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/TFn">TFn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/U">U</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Val">Val</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Value">Value</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Var1">Var1</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Var2">Var2</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/Vec">Vec</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann">ann</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-datatype">ann-datatype</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-form">ann-form</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-interface">ann-interface</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-many">ann-many</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-precord">ann-precord</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-protocol">ann-protocol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-record">ann-record</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/atom">atom</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/atom&gt;">atom&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/cf">cf</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-form*">check-form*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-form-info">check-form-info</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-ns">check-ns</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-ns-info">check-ns-info</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-alias-kind">declare-alias-kind</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-datatypes">declare-datatypes</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-names">declare-names</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-protocols">declare-protocols</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/def">def</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/def-alias">def-alias</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/def&gt;">def&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/defalias">defalias</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/defn">defn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/defn&gt;">defn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/defprotocol">defprotocol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/defprotocol&gt;">defprotocol&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/doseq">doseq</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/doseq&gt;">doseq&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/dotimes">dotimes</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/dotimes&gt;">dotimes&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/envs">envs</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/fn">fn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/fn&gt;">fn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/for">for</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/for&gt;">for&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/inst">inst</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/inst-ctor">inst-ctor</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/into-array&gt;">into-array&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/let">let</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/letfn&gt;">letfn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/load-if-needed">load-if-needed</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/loop">loop</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/loop&gt;">loop&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/method-type">method-type</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/nilable-param">nilable-param</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/non-nil-return">non-nil-return</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/override-constructor">override-constructor</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/override-method">override-method</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/pfn&gt;">pfn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/pred">pred</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/print-env">print-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/print-filterset">print-filterset</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ref">ref</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ref&gt;">ref&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/reset-caches">reset-caches</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/statistics">statistics</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/tc-ignore">tc-ignore</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/typed-deps">typed-deps</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/var-coverage">var-coverage</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/var&gt;">var&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/when-let-fail">when-let-fail</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.async" style="margin-top: 3px;">clojure.core.typed.async</a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.base-env-common" style="margin-top: 3px;">clojure.core.typed.base-env-common</a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.check-form-cljs" style="margin-top: 3px;">clojure.core.typed.check-form-cljs</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.check-form-cljs/check-form-cljs">check-form-cljs</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.check-ns-clj" style="margin-top: 3px;">clojure.core.typed.check-ns-clj</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.check-ns-clj/check-ns-info">check-ns-info</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.collect-utils" style="margin-top: 3px;">clojure.core.typed.collect-utils</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.collect-utils/collect-ns*">collect-ns*</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.hole" style="margin-top: 3px;">clojure.core.typed.hole</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/NoisyHole">NoisyHole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/noisy-hole">noisy-hole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/silent-hole">silent-hole</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.macros" style="margin-top: 3px;">clojure.core.typed.macros</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/ann-form">ann-form</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/atom">atom</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/def">def</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/defn">defn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/defprotocol">defprotocol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/fn">fn</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/let">let</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/loop">loop</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/parse-colon">parse-colon</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/ref">ref</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/tc-ignore">tc-ignore</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.macros/when-let-fail">when-let-fail</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.statistics" style="margin-top: 3px;">clojure.core.typed.statistics</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.statistics/statistics">statistics</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.util-vars" style="margin-top: 3px;">clojure.core.typed.util-vars</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.util-vars/*checking*">*checking*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.util-vars/*trace-checker*">*trace-checker*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.util-vars/*verbose-forms*">*verbose-forms*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.util-vars/*verbose-types*">*verbose-types*</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.typed">clojure.core.typed</span>
  - <span id="header-project">Gradual Typing</span> <span id="header-version">0.2.73</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.core.typed</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/core.typed/">http://github.com/clojure/core.typed/</a></div>
<pre id="namespace-docstr">This namespace contains typed wrapper macros, type aliases
and functions for type checking Clojure code. check-ns is the interface
for checking namespaces, cf for checking individual forms.</pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ASeq">ASeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (ASeq t)
</pre>
    <pre id="var-docstr">A sequential seq returned from clojure.core/seq

(TFn
 [[x :variance :covariant]]
 (I
  (clojure.lang.ISeq x)
  clojure.lang.Sequential
  (Iterable x)
  (java.util.Collection x)
  (java.util.List x)
  clojure.lang.IObj))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AVec">AVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (AVec t)
</pre>
    <pre id="var-docstr">A persistent vector returned from clojure.core/vector (and others)

(TFn
 [[x :variance :covariant]]
 (I
  (clojure.lang.IPersistentVector x)
  (java.lang.Iterable x)
  (java.util.Collection x)
  (java.util.List x)
  clojure.lang.IObj))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Agent1">Agent1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Agent1 t)
</pre>
    <pre id="var-docstr">An agent that can read and write type x.

(TFn [[x :variance :invariant]] (clojure.lang.Agent x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Agent2">Agent2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Agent2 t t)
</pre>
    <pre id="var-docstr">An agent that can write type w and read type r.

(TFn
 [[w :variance :contravariant] [r :variance :covariant]]
 (clojure.lang.Agent w r))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/All">All</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (All binder type)
</pre>
    <pre id="var-docstr">A polymorphic binder</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1448" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Any">Any</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Any
</pre>
    <pre id="var-docstr">Any is the top type that contains all types.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1308" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AnyInteger">AnyInteger</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: AnyInteger
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/integer?

(U Integer Long clojure.lang.BigInt BigInteger Short Byte)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/AnyValue">AnyValue</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: AnyValue
</pre>
    <pre id="var-docstr">AnyValue contains all Value singleton types</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1313" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Assoc">Assoc</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Assoc type type-pairs*)
</pre>
    <pre id="var-docstr">A type representing an assoc operation</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1427" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Atom1">Atom1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Atom1 t)
</pre>
    <pre id="var-docstr">An atom that can read and write type x.

(TFn [[x :variance :invariant]] (clojure.lang.Atom x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Atom2">Atom2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Atom2 t)
</pre>
    <pre id="var-docstr">An atom that can write type w and read type r.

(TFn
 [[w :variance :contravariant] [r :variance :covariant]]
 (clojure.lang.Atom w r))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/BlockingDeref">BlockingDeref</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (BlockingDeref t)
</pre>
    <pre id="var-docstr">A Clojure blocking derefable (see clojure.core/deref).

(TFn [[x :variance :covariant]] (clojure.lang.IBlockingDeref x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Bool">Bool</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Bool
</pre>
    <pre id="var-docstr">A boolean

java.lang.Boolean</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Coll">Coll</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Coll t)
</pre>
    <pre id="var-docstr">A persistent collection with member type x.

(TFn [[x :variance :covariant]] (clojure.lang.IPersistentCollection x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/CountRange">CountRange</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (CountRange Integer)
       (CountRange Integer Integer)
</pre>
    <pre id="var-docstr">A type representing a range of counts for a collection</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1346" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Delay">Delay</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Delay t)
</pre>
    <pre id="var-docstr">A Clojure delay (see clojure.core/{delay,force}).

(TFn [[x :variance :covariant]] (clojure.lang.Delay x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Deref">Deref</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Deref t)
</pre>
    <pre id="var-docstr">A Clojure derefable (see clojure.core/deref).

(TFn [[x :variance :covariant]] (clojure.lang.IDeref x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Difference">Difference</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Difference type type type*)
</pre>
    <pre id="var-docstr">Difference represents a difference of types.

(Difference t s) is the same as type t with type s removed.

eg. (Difference (U Int Long) Int) =&gt; Long
    (Difference (U Num nil) nil)  =&gt; Num
</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1357" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Dissoc">Dissoc</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Dissoc type type*)
</pre>
    <pre id="var-docstr">A type representing a dissoc operation</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1432" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/EmptyCount">EmptyCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: EmptyCount
</pre>
    <pre id="var-docstr">The type of all things with count 0. Use as part of an intersection.
eg. See EmptySeqable.

(ExactCount 0)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/EmptySeqable">EmptySeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (EmptySeqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x
with count 0.

(TFn
 [[x :variance :covariant]]
 (I (clojure.lang.Seqable x) (ExactCount 0)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ExInfo">ExInfo</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: ExInfo
</pre>
    <pre id="var-docstr">A Clojure custom exception type.

(I clojure.lang.IExceptionInfo RuntimeException)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ExactCount">ExactCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (ExactCount Integer)
</pre>
    <pre id="var-docstr">A type representing a precise count for a collection</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1352" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Fn">Fn</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Fn
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/fn?

clojure.lang.Fn</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Future">Future</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Future t)
</pre>
    <pre id="var-docstr">A Clojure future (see clojure.core/{future-call,future}).

(TFn
 [[x :variance :covariant]]
 (Extends
  [(clojure.lang.IDeref x)
   (clojure.lang.IBlockingDeref x)
   clojure.lang.IPending
   java.util.concurrent.Future]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Get">Get</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Get type type)
       (Get type type type)
</pre>
    <pre id="var-docstr">A type representing a get operation</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1437" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HMap">HMap</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HMap :mandatory {Constant Type*} :optional {Constant Type*} :absent-keys #{Constant*} :complete? Boolean)
       (quote {Constant Type*})
</pre>
    <pre id="var-docstr">HMap is a type for heterogeneous maps.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1380" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HSeq">HSeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HSeq [fixed*] :filter-sets [FS*] :objects [obj*])
       (HSeq [fixed* rest *] :filter-sets [FS*] :objects [obj*])
       (HSeq [fixed* drest ... bound] :filter-sets [FS*] :objects [obj*])
</pre>
    <pre id="var-docstr">HSeq is a type for heterogeneous seqs</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1396" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HSequential">HSequential</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HSequential [fixed*] :filter-sets [FS*] :objects [obj*])
       (HSequential [fixed* rest *] :filter-sets [FS*] :objects [obj*])
       (HSequential [fixed* drest ... bound] :filter-sets [FS*] :objects [obj*])
</pre>
    <pre id="var-docstr">HSequential is a type for heterogeneous sequential collections</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1389" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HSet">HSet</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HSet #{fixed*} :complete? Boolean)
</pre>
    <pre id="var-docstr">HSet is a type for heterogeneous sets.
Takes a set of simple values. By default
:complete? is true.

eg. (HSet #{:a :b :c} :complete? true)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1403" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/HVec">HVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (HVec [fixed*] :filter-sets [FS*] :objects [obj*])
       (HVec [fixed* type *] :filter-sets [FS*] :objects [obj*])
       (HVec [fixed* type ... bound] :filter-sets [FS*] :objects [obj*])
       (quote [fixed*])
       (quote [fixed* type *])
       (quote [fixed* type ... bound])
</pre>
    <pre id="var-docstr">HVec is a type for heterogeneous vectors.
It extends clojure.core.typed/Vec and is a subtype
of clojure.core.typed/HSequential.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1368" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Hierarchy">Hierarchy</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Hierarchy
</pre>
    <pre id="var-docstr">A hierarchy for use with derive, isa? etc.

'{:parents (clojure.lang.IPersistentMap Any Any),
  :ancestors (clojure.lang.IPersistentMap Any Any),
  :descendants (clojure.lang.IPersistentMap Any Any)}</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/I">I</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (I type*)
</pre>
    <pre id="var-docstr">I represents an intersection of types</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1329" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/IFn">IFn</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (IFn ArityVec+)
       [fixed* -&gt; ret :filters {:then fl, :else fl} :object {:id Foo, :path Bar}]
       [fixed* rest * -&gt; ret :filters {:then fl, :else fl} :object {:id Foo, :path Bar}]
       [fixed* drest ... bound -&gt; ret :filters {:then fl, :else fl} :object {:id Foo, :path Bar}]
</pre>
    <pre id="var-docstr">An ordered intersection type of function arities.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1412" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Id">Id</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Id
</pre>
    <pre id="var-docstr">The identity function at the type level.

(TFn [[x :variance :covariant]] x)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Int">Int</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Int
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/integer?

(U Integer Long clojure.lang.BigInt BigInteger Short Byte)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Keyword">Keyword</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Keyword
</pre>
    <pre id="var-docstr">A keyword

clojure.lang.Keyword</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Kw">Kw</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Kw
</pre>
    <pre id="var-docstr">A keyword

clojure.lang.Keyword</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/List">List</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (List t)
</pre>
    <pre id="var-docstr">A Clojure persistent list.

(TFn [[x :variance :covariant]] (clojure.lang.IPersistentList x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Map">Map</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Map t t)
</pre>
    <pre id="var-docstr">A persistent map with keys k and vals v.

(TFn
 [[k :variance :covariant] [v :variance :covariant]]
 (clojure.lang.IPersistentMap k v))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Multi">Multi</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Multi
</pre>
    <pre id="var-docstr">A Clojure multimethod.

clojure.lang.MultiFn</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Namespace">Namespace</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Namespace
</pre>
    <pre id="var-docstr">A namespace

clojure.lang.Namespace</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Nilable">Nilable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Nilable t)
</pre>
    <pre id="var-docstr">A union of x and nil.

(TFn [[x :variance :covariant]] (U nil x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NilableNonEmptyASeq">NilableNonEmptyASeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NilableNonEmptyASeq t)
</pre>
    <pre id="var-docstr">The result of clojure.core/seq.

(TFn
 [[x :variance :covariant]]
 (U
  nil
  (I
   (clojure.lang.ISeq x)
   clojure.lang.Sequential
   (Iterable x)
   (java.util.Collection x)
   (java.util.List x)
   clojure.lang.IObj
   (CountRange 1))))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NilableNonEmptySeq">NilableNonEmptySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NilableNonEmptySeq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x with count greater than 0, or nil.

(TFn
 [[x :variance :covariant]]
 (U nil (I (clojure.lang.ISeq x) (CountRange 1))))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyASeq">NonEmptyASeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyASeq t)
</pre>
    <pre id="var-docstr">A sequential non-empty seq retured from clojure.core/seq

(TFn
 [[x :variance :covariant]]
 (I
  (clojure.lang.ISeq x)
  clojure.lang.Sequential
  (Iterable x)
  (java.util.Collection x)
  (java.util.List x)
  clojure.lang.IObj
  (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyAVec">NonEmptyAVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyAVec t)
</pre>
    <pre id="var-docstr">A persistent vector returned from clojure.core/vector (and others) and count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I
  (clojure.lang.IPersistentVector x)
  (java.lang.Iterable x)
  (java.util.Collection x)
  (java.util.List x)
  clojure.lang.IObj
  (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyColl">NonEmptyColl</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyColl t)
</pre>
    <pre id="var-docstr">A persistent collection with member type x and count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I (clojure.lang.IPersistentCollection x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyCount">NonEmptyCount</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: NonEmptyCount
</pre>
    <pre id="var-docstr">The type of all things with count greater than 0. Use as part of an intersection.
eg. See NonEmptySeq

(CountRange 1)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyLazySeq">NonEmptyLazySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyLazySeq t)
</pre>
    <pre id="var-docstr">A non-empty lazy sequence of type t

(TFn
 [[t :variance :covariant]]
 (I (clojure.lang.LazySeq t) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptySeq">NonEmptySeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptySeq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x with count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I (clojure.lang.ISeq x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptySeqable">NonEmptySeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptySeqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x
with count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I (clojure.lang.Seqable x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/NonEmptyVec">NonEmptyVec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (NonEmptyVec t)
</pre>
    <pre id="var-docstr">A persistent vector with member type x and count greater than 0.

(TFn
 [[x :variance :covariant]]
 (I (clojure.lang.IPersistentVector x) (CountRange 1)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Nothing">Nothing</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Nothing
</pre>
    <pre id="var-docstr">Nothing is the bottom type that inhabits no types
except itself.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1323" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Num">Num</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Num
</pre>
    <pre id="var-docstr">A type that returns true for clojure.core/number?

Number</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Option">Option</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Option t)
</pre>
    <pre id="var-docstr">A union of x and nil.

(TFn [[x :variance :covariant]] (U nil x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Pred">Pred</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Pred type)
</pre>
    <pre id="var-docstr">A predicate for the given type.

eg. Type for integer?: (Pred Int)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1420" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Promise">Promise</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Promise t)
</pre>
    <pre id="var-docstr">A Clojure promise (see clojure.core/{promise,deliver}).

(TFn
 [[x :variance :invariant]]
 (Rec
  [p]
  (I
   (Extends
    [(clojure.lang.IDeref x)
     (clojure.lang.IBlockingDeref x)
     clojure.lang.IPending])
   [x -&gt; (U nil p)])))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Proxy">Proxy</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Proxy
</pre>
    <pre id="var-docstr">A Clojure proxy.

clojure.lang.IProxy</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Rec">Rec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Rec binder type)
</pre>
    <pre id="var-docstr">A recursive type</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1443" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Ref1">Ref1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Ref1 t)
</pre>
    <pre id="var-docstr">A ref that can read and write type x.

(TFn [[x :variance :invariant]] (clojure.lang.Ref x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Ref2">Ref2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Ref2 w r)
</pre>
    <pre id="var-docstr">A ref that can write type w and read type r.

(TFn
 [[w :variance :contravariant] [r :variance :covariant]]
 (clojure.lang.Ref w r))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Reversible">Reversible</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Reversible t)
</pre>
    <pre id="var-docstr">A Clojure reversible collection.

(TFn [[x :variance :covariant]] (clojure.lang.Reversible x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Seq">Seq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Seq t)
</pre>
    <pre id="var-docstr">A persistent sequence of member type x.

(TFn [[x :variance :covariant]] (clojure.lang.ISeq x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Seqable">Seqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Seqable t)
</pre>
    <pre id="var-docstr">A type that can be used to create a sequence of member type x.

(TFn [[x :variance :covariant]] (clojure.lang.Seqable x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Sequential">Sequential</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Sequential
</pre>
    <pre id="var-docstr">A sequential collection.

clojure.lang.Sequential</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SequentialSeq">SequentialSeq</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SequentialSeq t)
</pre>
    <pre id="var-docstr">A Clojure sequential sequence. Seq's aren't always Sequential.

(TFn
 [[x :variance :covariant]]
 (I clojure.lang.Sequential (clojure.lang.ISeq x)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SequentialSeqable">SequentialSeqable</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SequentialSeqable t)
</pre>
    <pre id="var-docstr">A sequential, seqable collection. Seq's aren't always Sequential.

(TFn
 [[x :variance :covariant]]
 (I clojure.lang.Sequential (clojure.lang.Seqable x)))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Set">Set</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Set t)
</pre>
    <pre id="var-docstr">A persistent set with member type x

(TFn [[x :variance :covariant]] (clojure.lang.IPersistentSet x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/SortedSet">SortedSet</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (SortedSet t)
</pre>
    <pre id="var-docstr">A sorted persistent set with member type x

(TFn
 [[x :variance :covariant]]
 (Extends [(clojure.lang.IPersistentSet x) clojure.lang.Sorted]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Stack">Stack</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Stack t)
</pre>
    <pre id="var-docstr">A Clojure stack.

(TFn [[x :variance :covariant]] (clojure.lang.IPersistentStack x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Str">Str</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Str
</pre>
    <pre id="var-docstr">A string

java.lang.String</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Sym">Sym</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Sym
</pre>
    <pre id="var-docstr">A symbol

clojure.lang.Symbol</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Symbol">Symbol</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: Symbol
</pre>
    <pre id="var-docstr">A symbol

clojure.lang.Symbol</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/TFn">TFn</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (TFn binder type)
</pre>
    <pre id="var-docstr">A type function</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1453" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/U">U</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (U type*)
</pre>
    <pre id="var-docstr">U represents a union of types</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1318" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Val">Val</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Val Constant)
       (quote Constant)
</pre>
    <pre id="var-docstr">A singleton type for a constant value.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1334" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Value">Value</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Value Constant)
       (quote Constant)
</pre>
    <pre id="var-docstr">A singleton type for a constant value.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1340" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Var1">Var1</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Var1 t)
</pre>
    <pre id="var-docstr">An var that can read and write type x.

(TFn [[x :variance :invariant]] (clojure.lang.Var x x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Var2">Var2</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Var2 w r)
</pre>
    <pre id="var-docstr">An var that can write type w and read type r.

(TFn
 [[w :variance :contravariant] [r :variance :covariant]]
 (clojure.lang.Var w r))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/Vec">Vec</h2>
    <span id="var-type">type alias</span><br />
    <pre id="var-usage">Usage: (Vec t)
</pre>
    <pre id="var-docstr">A persistent vector with member type x.

(TFn [[x :variance :covariant]] (clojure.lang.IPersistentVector x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann">ann</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann varsym typesyn)
</pre>
    <pre id="var-docstr">Annotate varsym with type. If unqualified, qualify in the current namespace.
If varsym has metadata {:no-check true}, ignore definitions of varsym 
while type checking.

If annotating vars in namespaces other than the current one, a fully
qualified symbol must be provided. Note that namespace aliases are not
recognised: the *full* namespace must be given in the first part of the symbol.

eg. ; annotate the var foo in this namespace
    (ann foo [Number -&gt; Number])

    ; annotate a var in another namespace
    (ann another.ns/bar [-&gt; nil])
 
    ; don't check this var
    (ann ^:no-check foobar [Integer -&gt; String])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1679" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-datatype">ann-datatype</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-datatype dname [field :- type*] opts*)
       (ann-datatype binder dname [field :- type*] opts*)
</pre>
    <pre id="var-docstr">Annotate datatype Class name dname with expected fields.
If unqualified, qualify in the current namespace.
Takes an optional type variable binder before the name.

Fields must be specified in the same order as presented 
in deftype, with exactly the same field names.

Also annotates datatype factories and constructors.

Binder is a vector of specs. Each spec is a vector
with the variable name as the first entry, followed by
keyword arguments:
- :variance (mandatory)
  The declared variance of the type variable. Possible
  values are :covariant, :contravariant and :invariant.
- :&lt; (optional)
  The upper type bound of the type variable. Defaults to
  Any, or the most general type of the same rank as the
  lower bound.
- :&gt; (optional)
  The lower type bound of the type variable. Defaults to
  Nothing, or the least general type of the same rank as the
  upper bound.

eg. ; a datatype in the current namespace
    (ann-datatype MyDatatype [a :- Number,
                              b :- Long])

    ; a datatype in another namespace
    (ann-datatype another.ns.TheirDatatype
                  [str :- String,
                   vec :- (Vec Number)])

    ; a datatype, polymorphic in a
    (ann-datatype [[a :variance :covariant]]
                  MyPolyDatatype
                  [str :- String,
                   vec :- (Vec Number)
                   ply :- (Set a)])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1734" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-form">ann-form</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-form form ty)
</pre>
    <pre id="var-docstr">Annotate a form with an expected type.</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-interface">ann-interface</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-interface vbnd varsym &amp; methods)
       (ann-interface varsym &amp; methods)
</pre>
    <pre id="var-docstr">Annotate a possibly polymorphic interface (created with definterface) with method types.

Note: Unlike ann-protocol, omit the target ('this') argument in the method signatures.

eg. (ann-interface IFoo
      bar
      (Fn [-&gt; Any]
          [Number Symbol -&gt; Any])
      baz
      [Number -&gt; Number])
    (definterface IFoo
      (bar [] [n s])
      (baz [n]))

    ; polymorphic protocol
    ; x is scoped in the methods
    (ann-protocol [[x :variance :covariant]]
      IFooPoly
      bar
      (Fn [-&gt; Any]
          [Number Symbol -&gt; Any])
      baz
      [Number -&gt; Number])
    (definterface IFooPoly
      (bar [] [n s])
      (baz [n]))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1966" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-many">ann-many</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-many t &amp; vs)
</pre>
    <pre id="var-docstr">Annotate several vars with type t.

eg. (ann-many FakeSearch
              web1 web2 image1 image2 video1 video2)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1720" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-precord">ann-precord</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-precord dname vbnd fields &amp; {ancests :unchecked-ancestors, rplc :replace, :as opt})
</pre>
    <pre id="var-docstr">Annotate record Class name dname with a polymorphic binder and expected fields.
If unqualified, qualify in the current namespace.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1893" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-protocol">ann-protocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-protocol vbnd varsym &amp; methods)
       (ann-protocol varsym &amp; methods)
</pre>
    <pre id="var-docstr">Annotate a possibly polymorphic protocol var with method types.

eg. (ann-protocol IFoo
      bar
      (Fn [IFoo -&gt; Any]
          [IFoo Number Symbol -&gt; Any])
      baz
      [IFoo Number -&gt; Number])
    (defprotocol&gt; IFoo
      (bar [this] [this n s])
      (baz [this n]))

    ; polymorphic protocol
    ; x is scoped in the methods
    (ann-protocol [[x :variance :covariant]]
      IFooPoly
      bar
      (Fn [(IFooPoly x) -&gt; Any]
          [(IFooPoly x) Number Symbol -&gt; Any])
      baz
      [(IFooPoly x) Number -&gt; Number])
    (defprotocol&gt; IFooPoly
      (bar [this] [this n s])
      (baz [this n]))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1907" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-record">ann-record</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-record dname [field :- type*] opts*)
       (ann-record binder dname [field :- type*] opts*)
</pre>
    <pre id="var-docstr">Annotate record Class name dname with expected fields.
If unqualified, qualify in the current namespace.
Takes an optional type variable binder before the name.

Fields must be specified in the same order as presented 
in defrecord, with exactly the same field names.

Also annotates record factories and constructors.

Binder is a vector of specs. Each spec is a vector
with the variable name as the first entry, followed by
keyword arguments:
- :variance (mandatory)
  The declared variance of the type variable. Possible
  values are :covariant, :contravariant and :invariant.
- :&lt; (optional)
  The upper type bound of the type variable. Defaults to
  Any, or the most general type of the same rank as the
  lower bound.
- :&gt; (optional)
  The lower type bound of the type variable. Defaults to
  Nothing, or the least general type of the same rank as the
  upper bound.

eg. ; a record in the current namespace
    (ann-record MyRecord [a :- Number,
                          b :- Long])

    ; a record in another namespace
    (ann-record another.ns.TheirRecord
                  [str :- String,
                   vec :- (Vec Number)])

    ; a record, polymorphic in a
    (ann-record [[a :variance :covariant]]
                MyPolyRecord
                [str :- String,
                 vec :- (Vec Number)
                 ply :- (Set a)])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1822" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/atom">atom</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom &amp; args)
</pre>
    <pre id="var-docstr">Like atom, but with optional type annotations.

Same as (atom (ann-form init t) args*)

eg. (atom 1) : (Atom1 (Value 1))
    (atom :- Num, 1) : (Atom1 Num)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/atom&gt;">atom&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom&gt; t init &amp; args)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/atom

Like atom, but creates an Atom1 of type t.

Same as (atom (ann-form init t) args*)

eg. (atom&gt; Number 1)
    (atom&gt; (Vec Any) [])</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.58</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1199" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/cf">cf</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (cf form)
       (cf form expected)
</pre>
    <pre id="var-docstr">Takes a form and an optional expected type and
returns a human-readable inferred type for that form.
Throws an exception if type checking fails.

Do not use cf inside a typed namespace. cf is intended to be
used at the REPL or within a unit test. Note that testing for
truthiness is not sufficient to unit test a call to cf, as nil
and false are valid type syntax.

cf preserves annotations from previous calls to check-ns or cf,
and keeps any new ones collected during a cf. This is useful for
debugging and experimentation. cf may be less strict than check-ns
with type checker warnings.

eg. (cf 1) 
    ;=&gt; Long

    (cf #(inc %) [Number -&gt; Number])
    ;=&gt; [Number -&gt; Number]</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2146" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-form*">check-form*</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Takes a (quoted) form and optional expected type syntax and
type checks the form. If expected is provided, type-provided?
must be true.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2134" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-form-info">check-form-info</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Type checks a (quoted) form and returns a map of results from type checking the
form.

Options
- :expected        Type syntax representing the expected type for this form
                   type-provided? option must be true to utilise the type.
- :type-provided?  If true, use the expected type to check the form
- :profile         Use Timbre to profile the type checker. Timbre must be
                   added as a dependency.
- :file-mapping    If true, return map provides entry :file-mapping, a hash-map
                   of (Map '{:line Int :column Int :file Str} Str).
- :checked-ast     Returns the entire AST for the given form as the :checked-ast entry,
                   annotated with the static types inferred after checking.

Default return map
- :delayed-errors  A sequence of delayed errors (ex-info instances)
- :ret             TCResult inferred for the current form</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2112" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns">check-ns</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Type check a namespace/s (a symbol or Namespace, or collection).
If not provided default to current namespace.
Returns a true value if type checking is successful, otherwise
throws an Exception.

Do not use check-ns within a checked namespace.
It is intended to be used at the REPL or within a unit test.
Suggested idiom for clojure.test: (is (check-ns 'your.ns))

check-ns resets annotations collected from 
previous check-ns calls or cf. A successful check-ns call will
preserve any type annotations collect during that checking run.

Keyword arguments:
- :collect-only  if true, collect type annotations but don't type check code.
                 Useful for debugging purposes.
- :trace         if true, print some basic tracing of the type checker
- :profile       if true, use Timbre to profile type checking. Must include
                 Timbre as a dependency.

If providing keyword arguments, the namespace to check must be provided
as the first argument.

Bind clojure.core.typed.util-vars/*verbose-types* to true to print fully qualified types.
Bind clojure.core.typed.util-vars/*verbose-forms* to print full forms in error messages.

eg. (check-ns 'myns.typed)
    ;=&gt; :ok
   
    ; implicitly check current namespace
    (check-ns)
    ;=&gt; :ok

    ; collect but don't check the current namespace
    (check-ns *ns* :collect-only true)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2186" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns-info">check-ns-info</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Same as check-ns, but returns a map of results from type checking the
namespace.

Options
- :collect-only    Don't type check the given namespace/s, but collect the 
                   top level type annotations like ann, ann-record.
- :type-provided?  If true, use the expected type to check the form
- :profile         Use Timbre to profile the type checker. Timbre must be
                   added as a dependency.
- :file-mapping    If true, return map provides entry :file-mapping, a hash-map
                   of (Map '{:line Int :column Int :file Str} Str).</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2169" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-alias-kind">declare-alias-kind</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-alias-kind sym ty)
</pre>
    <pre id="var-docstr">Declare a kind for an alias, similar to declare but on the kind level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1163" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-datatypes">declare-datatypes</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-datatypes &amp; syms)
</pre>
    <pre id="var-docstr">Declare datatypes, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1141" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-names">declare-names</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-names &amp; syms)
</pre>
    <pre id="var-docstr">Declare names, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1176" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-protocols">declare-protocols</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-protocols &amp; syms)
</pre>
    <pre id="var-docstr">Declare protocols, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1152" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def">def</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def name docstring? :- type? expr)
</pre>
    <pre id="var-docstr">Like clojure.core/def with optional type annotations

NB: in Clojure it is impossible to refer a var called `def` as it is a
special form. Use an alias prefix (eg. `t/def`).

If an annotation is provided, a corresponding `ann` form
is generated, otherwise it expands identically to clojure.core/def

eg. ;same as clojure.core/def
    (def vname 1)
    
    ;with Number `ann`
    (def vname :- Number 1)

    ;doc
    (def vname
      "Docstring"
      :- Long
      1)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def-alias">def-alias</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def-alias sym doc-str t)
       (def-alias sym t)
</pre>
    <pre id="var-docstr">DEPRECATED: use defalias

Define a type alias. Takes an optional doc-string as a second
argument.

Updates the corresponding var with documentation.

eg. (def-alias MyAlias
      "Here is my alias"
      (U nil String))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1235" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def&gt;">def&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def&gt; name docstring? :- type expr)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/def

Like def, but with annotations.

eg. (def&gt; vname :- Long 1)

;doc
(def&gt; vname
  "Docstring"
  :- Long
  1)</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L763" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defalias">defalias</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defalias sym doc-str t)
       (defalias sym t)
</pre>
    <pre id="var-docstr">Define a type alias. Takes an optional doc-string as a second
argument.

Updates the corresponding var with documentation.

eg. (defalias MyAlias
      "Here is my alias"
      (U nil String))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1268" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defn">defn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn poly? name docstring? [param :- type *] :- type exprs*)
       (defn poly? name docstring? ([param :- type *] :- type exprs*) +)
</pre>
    <pre id="var-docstr">Like defn, but with optional annotations. All annotations default to Any,
like the typed fn macro. Rest parameters default to starred.

eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)

;annotate return
(defn fname [a :- String] :- String ...)

;multi-arity
(defn fname 
  ([a :- String] :- String ...)
  ([a :- String, b :- Number] :- Long ...))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defn&gt;">defn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn&gt; name docstring? :- type [param :- type *] exprs*)
       (defn&gt; name docstring? (:- type [param :- type *] exprs*) +)
</pre>
    <pre id="var-docstr">DEPRECATED: Use defn

Like defn, but with annotations. Annotations are mandatory for
parameters and for return type.

eg. (defn&gt; fname :- Integer [a :- Number, b :- (U Symbol nil)] ...)

;annotate return
(defn&gt; fname :- String [a :- String] ...)

;multi-arity
(defn&gt; fname 
  (:- String [a :- String] ...)
  (:- Long   [a :- String, b :- Number] ...))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.57</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L730" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defprotocol">defprotocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defprotocol &amp; body)
</pre>
    <pre id="var-docstr">Like defprotocol, but with optional type annotations.

Omitted annotations default to Any. The first argument
of a protocol cannot be annotated.

Add a binder before the protocol name to define a polymorphic
protocol. A binder before the method name defines a polymorphic
method, however a method binder must not shadow type variables
introduced by a protocol binder.

Return types for each method arity can be annotated.

Unlike clojure.core/defprotocol, successive methods can
have the same arity. Semantically, providing multiple successive
methods of the same arity is the same as just providing the left-most
method. However the types for these methods will be accumulated into
a Fn type.

eg. ;annotate single method
(defprotocol MyProtocol
  (a [this a :- Integer] :- Number))

;polymorphic protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Number))

;multiple types for the same method
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Integer
     [this a :- Long] :- Long
     [this a :- Number] :- Number))

;polymorphic method+protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  ([y] a [this a :- x, b :- y] :- y))
</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/defprotocol&gt;">defprotocol&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defprotocol&gt; &amp; body)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/defprotocol

Like defprotocol, but required for type checking
its macroexpansion.

eg. (defprotocol&gt; MyProtocol
      (a [this]))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1067" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/doseq">doseq</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (doseq seq-exprs &amp; body)
</pre>
    <pre id="var-docstr">Like clojure.core/doseq with optional annotations.

:let option uses clojure.core.typed/let

eg.
(doseq [a :- (U nil AnyInteger) [1 nil 2 3]
        :when a]
   (inc a))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L571" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/doseq&gt;">doseq&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (doseq&gt; seq-exprs &amp; body)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/doseq

Like doseq but requires annotation for each loop variable: 
[a [1 2]] becomes [a :- Long [1 2]]

eg.
(doseq&gt; [a :- (U nil AnyInteger) [1 nil 2 3]
         :when a]
   (inc a))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L466" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/dotimes">dotimes</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dotimes bindings &amp; body)
</pre>
    <pre id="var-docstr">Like clojure.core/dotimes, but with optional annotations.

If annotation for binding is omitted, defaults to Int.

eg. (dotimes [_ 100]
      (println "like normal"))

    (dotimes [x :- Num, 100.123]
      (println "like normal" x))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L170" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/dotimes&gt;">dotimes&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dotimes&gt; bindings &amp; body)
</pre>
    <pre id="var-docstr">DEPRECATED: Use clojure.core.typed/dotimes

Like dotimes.

eg. (dotimes&gt; [_ 100]
      (println "like normal"))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L147" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/envs">envs</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Returns a map of type environments, according to the current state of the
type checker.

Output map:
- :vars      map from var symbols to their verbosely printed types
- :aliases   map from alias var symbols (made with defalias) to their verbosely printed types
- :special-types  a set of Vars that are special to the type checker (like Any, U, I)
</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2246" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/fn">fn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn name? [param :- type* &amp; param :- type * ?] :- type? exprs*)
       (fn name? ([param :- type* &amp; param :- type * ?] :- type? exprs*) +)
</pre>
    <pre id="var-docstr">Like clojure.core/fn, but with optional annotations.

eg. ;these forms are equivalent
    (fn [a] b)
    (fn [a :- Any] b)
    (fn [a :- Any] :- Any b)
    (fn [a] :- Any b)

    ;annotate return
    (fn [a :- String] :- String body)

    ;named fn
    (fn fname [a :- String] :- String body)

    ;rest parameter
    (fn [a :- String &amp; b :- Number *] body)

    ;dotted rest parameter
    (fn [a :- String &amp; b :- Number ... x] body)

    ;multi-arity
    (fn fname 
      ([a :- String] :- String ...)
      ([a :- String, b :- Number] :- String ...))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/fn&gt;">fn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn&gt; name? :- type? [param :- type* &amp; param :- type * ?] exprs*)
       (fn&gt; name? (:- type? [param :- type* &amp; param :- type * ?] exprs*) +)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/fn

Like fn, but with annotations. Annotations are mandatory
for parameters, with optional annotations for return type.
If fn is named, return type annotation is mandatory.

Suggested idiom: use commas between parameter annotation triples.

eg. (fn&gt; [a :- Number, b :- (U Symbol nil)] ...)

    ;annotate return
    (fn&gt; :- String [a :- String] ...)

    ;named fn
    (fn&gt; fname :- String [a :- String] ...)

    ;multi-arity
    (fn&gt; fname 
      (:- String [a :- String] ...)
      (:- Long   [a :- String, b :- Number] ...))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L687" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/for">for</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (for seq-exprs &amp; maybe-ann-body-expr)
</pre>
    <pre id="var-docstr">Like clojure.core/for with optional type annotations.

All types default to Any.

The :let option uses clojure.core.typed/let.

eg. (for [a :- (U nil Int) [1 nil 2 3]
          :when a]
      :- Number
      (inc a))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L325" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/for&gt;">for&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (for&gt; tk ret-ann seq-exprs body-expr)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/for

Like for but requires annotation for each loop variable: [a [1 2]] becomes [a :- Long [1 2]]
Also requires annotation for return type.

eg. (for&gt; :- Number
      [a :- (U nil AnyInteger) [1 nil 2 3]
       :when a]
      (inc a))</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L192" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst">inst</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a polymorphic type with a number of types.

eg. (inst foo-fn t1 t2 t3 ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L111" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst-ctor">inst-ctor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst-ctor inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a call to a constructor with a number of types.
First argument must be an immediate call to a constructor.
Returns exactly the instantiatee (the first argument).

eg. (inst-ctor (PolyCtor. a b c)
               t1 t2 ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L119" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/into-array&gt;">into-array&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (into-array&gt; cljt coll)
       (into-array&gt; javat cljt coll)
       (into-array&gt; into-array-syn javat cljt coll)
</pre>
    <pre id="var-docstr">Make a Java array with Java class javat and Typed Clojure type
cljt. Resulting array will be of type javat, but elements of coll must be under
cljt. cljt should be a subtype of javat (the same or more specific).

*Temporary hack*
into-array-syn is exactly the syntax to put as the first argument to into-array.
Calling resolve on this syntax should give the correct class.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1614" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/let">let</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (let [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/let but supports optional type annotations.

eg. (let [a :- Type, b
          a2 1.2]
      body)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/letfn&gt;">letfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (letfn&gt; [fn-spec-or-annotation*] expr*)
</pre>
    <pre id="var-docstr">Like letfn, but each function spec must be annotated.

eg. (letfn&gt; [a :- [Number -&gt; Number]
             (a [b] 2)

             c :- [Symbol -&gt; nil]
             (c [s] nil)]
      ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L795" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/load-if-needed">load-if-needed</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Load and initialize all of core.typed if not already</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L50" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/loop">loop</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/loop, and supports optional type annotations.
Arguments default to a generalised type based on the initial value.

eg. (loop [a :- Number 1
           b :- (U nil Number) nil]
      ...)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/loop&gt;">loop&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop&gt; [binding :- type init*] exprs*)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/loop

Like loop, except loop variables require annotation.

Suggested idiom: use a comma between the type and the initial
expression.

eg. (loop&gt; [a :- Number, 1
            b :- (U nil Number), nil]
      ...)</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.45</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1085" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/method-type">method-type</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Given a method symbol, print the core.typed types assigned to it.
Intended for use at the REPL.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L63" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/nilable-param">nilable-param</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (nilable-param msym mmap)
</pre>
    <pre id="var-docstr">Override which parameters in qualified method msym may accept
nilable values. If the parameter is a parameterised type or
an Array, this also declares the parameterised types and the Array type as nilable.

mmap is a map mapping arity parameter number to a set of parameter
positions (integers). If the map contains the key :all then this overrides
other entries. The key can also be :all, which declares all parameters nilable.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1653" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/non-nil-return">non-nil-return</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (non-nil-return msym arities)
</pre>
    <pre id="var-docstr">Override the return type of fully qualified method msym to be non-nil.
Takes a set of relevant arities,
represented by the number of parameters it takes (rest parameter counts as one),
or :all which overrides all arities.

eg. ; must use full class name
    (non-nil-return java.lang.Class/getDeclaredMethod :all)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1636" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-constructor">override-constructor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-constructor ctorsym typesyn)
</pre>
    <pre id="var-docstr">Override all constructors for Class ctorsym with type.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2035" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-method">override-method</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-method methodsym typesyn)
</pre>
    <pre id="var-docstr">Override type for qualified method methodsym.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2046" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/pfn&gt;">pfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (pfn&gt; &amp; forms)
</pre>
    <pre id="var-docstr">Define a polymorphic typed anonymous function.
(pfn&gt; name? [binder+] :- type? [[param :- type]* &amp; [param :- type *]?] exprs*)
(pfn&gt; name? [binder+] (:- type? [[param :- type]* &amp; [param :- type *]?] exprs*)+)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L678" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/pred">pred</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (pred t)
</pre>
    <pre id="var-docstr">Generate a flat (runtime) predicate for type that returns true if the
argument is a subtype of the type, otherwise false.

The current type variable and dotted type variable scope is cleared before parsing.

eg. ((pred Number) 1)
    ;=&gt; true</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2267" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-env">print-env</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">During type checking, print the type environment to *out*,
preceeded by literal string debug-str.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1667" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-filterset">print-filterset</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">During type checking, print the filter set attached to form, 
preceeded by literal string debug-string.
Returns nil.

eg. (let [s (seq (get-a-seqable))]
      (print-filterset "Here now" s))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L88" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ref">ref</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref &amp; args)
</pre>
    <pre id="var-docstr">Like ref, but with optional type annotations.

Same as (ref (ann-form init t) args*)

eg. (ref 1) : (Ref1 (Value 1))
    (ref :- Num, 1) : (Ref1 Num)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ref&gt;">ref&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref&gt; t init &amp; args)
</pre>
    <pre id="var-docstr">DEPRECATED: use clojure.core.typed/ref

Like ref, but creates a Ref1 of type t.

Same as (ref (ann-form init t) args*)

eg. (ref&gt; Number 1)
    (ref&gt; (Vec Any) [])</pre>
    
    <span class="var-deprecated"><span id="content">Deprecated since Gradual Typing version 0.2.58</span><br /></span>
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L1217" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/reset-caches">reset-caches</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Reset internal type caches.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L55" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/statistics">statistics</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Takes a collection of namespace symbols and returns a map mapping the namespace
symbols to a map of data</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2229" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/tc-ignore">tc-ignore</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (tc-ignore &amp; body)
</pre>
    <pre id="var-docstr">Ignore forms in body during type checking</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/typed-deps">typed-deps</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (typed-deps &amp; args)
</pre>
    <pre id="var-docstr">Declare namespaces which should be checked before the current namespace.
Accepts any number of symbols. Only has effect via check-ns.

eg. (typed-deps clojure.core.typed.holes
                myns.types)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2057" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/var-coverage">var-coverage</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Summarises annotated var coverage statistics to *out*
for namespaces nsyms, a collection of symbols or a symbol/namespace.
Defaults to the current namespace if no argument provided.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2237" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/var&gt;">var&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (var&gt; sym)
</pre>
    <pre id="var-docstr">Like var, but resolves at runtime like ns-resolve and is understood by
the type checker. sym must be fully qualified (without aliases).

eg. (var&gt; clojure.core/+)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2086" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (warn-on-unannotated-vars)
</pre>
    <pre id="var-docstr">Allow unannotated vars in the current namespace. 

Emits a warning instead of a type error when checking
a def without a corresponding expected type.

Disables automatic inference of `def` expressions.

eg. (warn-on-unannotated-vars)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/b5af118e42e0a13b3a6334b3ac536c78ff7e9e4d/module-rt/src/main/clojure/clojure/core/typed.clj#L2100" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/when-let-fail">when-let-fail</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (when-let-fail b &amp; body)
</pre>
    <pre id="var-docstr">Like when-let, but fails if the binding yields a false value.</pre>
    
    
    
  </div>
</div>
<br />
<h2 id="clojure.core.typed.async">clojure.core.typed.async</h2>
<pre id="namespace-docstr">This namespace contains annotations and helper macros for type
checking core.async code. Ensure clojure.core.async is require'd
before performing type checking.

go
  use go

chan
  use chan

buffer
  use buffer (similar for other buffer constructors)
</pre>


<br />



<br />
<h2 id="clojure.core.typed.base-env-common">clojure.core.typed.base-env-common</h2>
<pre id="namespace-docstr">Utilities for all implementations of the type checker</pre>


<br />



<br />
<h2 id="clojure.core.typed.check-form-cljs">clojure.core.typed.check-form-cljs</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check-form-cljs/check-form-cljs">check-form-cljs</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-form-cljs form expected expected-provided?)
</pre>
    <pre id="var-docstr">Check a single form with an optional expected type.
Intended to be called from Clojure. For evaluation at the Clojurescript
REPL see cf.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/0811ef9321f62be1ebab83c04b0f99620fd8e81e/module-check/src/main/clojure/clojure/core/typed/check_form_cljs.clj#L23" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.check-ns-clj">clojure.core.typed.check-ns-clj</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.check-ns-clj/check-ns-info">check-ns-info</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns-info ns-or-syms &amp; opt)
</pre>
    <pre id="var-docstr">Same as check-ns, but returns a map of results from type checking the
namespace.

Options
- :collect-only    Don't type check the given namespace/s, but collect the 
                   top level type annotations like ann, ann-record.
- :type-provided?  If true, use the expected type to check the form
- :profile         Use Timbre to profile the type checker. Timbre must be
                   added as a dependency.
- :file-mapping    If true, return map provides entry :file-mapping, a hash-map
                   of (Map '{:line Int :column Int :file Str} Str).</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/check_ns_clj.clj#L6" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.collect-utils">clojure.core.typed.collect-utils</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.collect-utils/collect-ns*">collect-ns*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (collect-ns* nsym {:keys [ast-for-ns collect-asts collect-ns]})
</pre>
    <pre id="var-docstr">Collect type annotations and dependency information
for namespace symbol nsym, and recursively check 
declared typed namespace dependencies.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/collect_utils.clj#L53" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.hole">clojure.core.typed.hole</h2>
<pre id="namespace-docstr">This namespace contains easy tools for hole driven development</pre>


<span id="see-also">See also: 
  <span id="see-also-link">
    <a href="http://matthew.brecknell.net/post/hole-driven-haskell/">Hole Driven Development</a>
  </span><br />
</span><br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/NoisyHole">NoisyHole</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NoisyHole)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.hole.NoisyHole.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/hole.clj#L17" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/noisy-hole">noisy-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (noisy-hole)
</pre>
    <pre id="var-docstr">A noisy hole. The type system will complain when
(noisy-hole) is used in positions that expect a type
more specific than Object or Any.
Use (noisy-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/hole.clj#L20" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/silent-hole">silent-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (silent-hole)
</pre>
    <pre id="var-docstr">A silent hole. (silent-hole) passes for any other type
when type checking.
Use (silent-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/hole.clj#L8" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.macros">clojure.core.typed.macros</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/ann-form">ann-form</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-form form ty)
</pre>
    <pre id="var-docstr">Annotate a form with an expected type.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L123" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/atom">atom</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (atom &amp; args)
</pre>
    <pre id="var-docstr">Like atom, but with optional type annotations.

Same as (atom (ann-form init t) args*)

eg. (atom 1) : (Atom1 (Value 1))
    (atom :- Num, 1) : (Atom1 Num)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L198" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/def">def</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def name docstring? :- type? expr)
</pre>
    <pre id="var-docstr">Like clojure.core/def with optional type annotations

NB: in Clojure it is impossible to refer a var called `def` as it is a
special form. Use an alias prefix (eg. `t/def`).

If an annotation is provided, a corresponding `ann` form
is generated, otherwise it expands identically to clojure.core/def

eg. ;same as clojure.core/def
    (def vname 1)
    
    ;with Number `ann`
    (def vname :- Number 1)

    ;doc
    (def vname
      "Docstring"
      :- Long
      1)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L22" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/defn">defn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defn poly? name docstring? [param :- type *] :- type exprs*)
       (defn poly? name docstring? ([param :- type *] :- type exprs*) +)
</pre>
    <pre id="var-docstr">Like defn, but with optional annotations. All annotations default to Any,
like the typed fn macro. Rest parameters default to starred.

eg. (defn fname [a :- Number, b :- (U Symbol nil)] :- Integer ...)

;annotate return
(defn fname [a :- String] :- String ...)

;multi-arity
(defn fname 
  ([a :- String] :- String ...)
  ([a :- String, b :- Number] :- Long ...))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L228" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/defprotocol">defprotocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (defprotocol &amp; body)
</pre>
    <pre id="var-docstr">Like defprotocol, but with optional type annotations.

Omitted annotations default to Any. The first argument
of a protocol cannot be annotated.

Add a binder before the protocol name to define a polymorphic
protocol. A binder before the method name defines a polymorphic
method, however a method binder must not shadow type variables
introduced by a protocol binder.

Return types for each method arity can be annotated.

Unlike clojure.core/defprotocol, successive methods can
have the same arity. Semantically, providing multiple successive
methods of the same arity is the same as just providing the left-most
method. However the types for these methods will be accumulated into
a Fn type.

eg. ;annotate single method
(defprotocol MyProtocol
  (a [this a :- Integer] :- Number))

;polymorphic protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Number))

;multiple types for the same method
(defprotocol [[x :variance :covariant]]
  MyProtocol
  (a [this a :- Integer] :- Integer
     [this a :- Long] :- Long
     [this a :- Number] :- Number))

;polymorphic method+protocol
(defprotocol [[x :variance :covariant]]
  MyProtocol
  ([y] a [this a :- x, b :- y] :- y))
</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L133" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/fn">fn</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn name? [param :- type* &amp; param :- type * ?] :- type? exprs*)
       (fn name? ([param :- type* &amp; param :- type * ?] :- type? exprs*) +)
</pre>
    <pre id="var-docstr">Like clojure.core/fn, but with optional annotations.

eg. ;these forms are equivalent
    (fn [a] b)
    (fn [a :- Any] b)
    (fn [a :- Any] :- Any b)
    (fn [a] :- Any b)

    ;annotate return
    (fn [a :- String] :- String body)

    ;named fn
    (fn fname [a :- String] :- String body)

    ;rest parameter
    (fn [a :- String &amp; b :- Number *] body)

    ;dotted rest parameter
    (fn [a :- String &amp; b :- Number ... x] body)

    ;multi-arity
    (fn fname 
      ([a :- String] :- String ...)
      ([a :- String, b :- Number] :- String ...))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L56" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/let">let</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (let [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/let but supports optional type annotations.

eg. (let [a :- Type, b
          a2 1.2]
      body)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L111" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/loop">loop</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop [binding :- type? init*] exprs*)
</pre>
    <pre id="var-docstr">Like clojure.core/loop, and supports optional type annotations.
Arguments default to a generalised type based on the initial value.

eg. (loop [a :- Number 1
           b :- (U nil Number) nil]
      ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L93" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/parse-colon">parse-colon</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (parse-colon fdecl name)
</pre>
    <pre id="var-docstr">Returns a vector of [provided? t args]</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L14" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/ref">ref</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ref &amp; args)
</pre>
    <pre id="var-docstr">Like ref, but with optional type annotations.

Same as (ref (ann-form init t) args*)

eg. (ref 1) : (Ref1 (Value 1))
    (ref :- Num, 1) : (Ref1 Num)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L213" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/tc-ignore">tc-ignore</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (tc-ignore &amp; body)
</pre>
    <pre id="var-docstr">Ignore forms in body during type checking</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L179" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.macros/when-let-fail">when-let-fail</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (when-let-fail b &amp; body)
</pre>
    <pre id="var-docstr">Like when-let, but fails if the binding yields a false value.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/6a0c8061c61ff4a85348201af4dce950ce459cbd/module-rt/src/main/clojure/clojure/core/typed/macros.clj#L191" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.statistics">clojure.core.typed.statistics</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.statistics/statistics">statistics</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (statistics nsyms)
</pre>
    <pre id="var-docstr">Takes a collection of namespace symbols and returns a map mapping the namespace
symbols to a map of data</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-check/src/main/clojure/clojure/core/typed/statistics.clj#L22" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.util-vars">clojure.core.typed.util-vars</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*checking*">*checking*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">True during type checking.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L37" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*trace-checker*">*trace-checker*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print tracing information during type checking.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L31" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*verbose-forms*">*verbose-forms*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print complete forms in error messages. Bind
around a type checking form like cf or check-ns.

eg.
(binding [*verbose-forms* true]
  (cf ['deep ['deep ['deep ['deep]]]] Number))
;=&gt; &lt;full form in error&gt;</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L19" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.util-vars/*verbose-types*">*verbose-types*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print fully qualified types in error messages
and return values. Bind around a type checking form like 
cf or check-ns.

eg. 
(binding [*verbose-types* true] 
  (cf 1 Number))
;=&gt; java.lang.Number</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/05369b9cbc4c9a26a79c0c97fcc161bfb723408c/module-rt/src/main/clojure/clojure/core/typed/util_vars.clj#L6" id="var-source">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">Copyright 2007-2014 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>